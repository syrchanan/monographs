[
  {
    "objectID": "posts/20250615-lambda-calculus/index.html",
    "href": "posts/20250615-lambda-calculus/index.html",
    "title": "Exploring Lambda Calculus (Part 3)",
    "section": "",
    "text": "TRUE = a =&gt; b =&gt; a\nFALSE = a =&gt; b =&gt; b\nN0 = f =&gt; a =&gt; a\nN1 = f =&gt; a =&gt; f(a)\nN2 = f =&gt; a =&gt; f(f(a))\nN3 = f =&gt; a =&gt; f(f(f(a)))\nN4 = f =&gt; a =&gt; f(f(f(f(a))))\nSUCC = n =&gt; f =&gt; x =&gt; f(n(f)(x))\nPLUS = m =&gt; n =&gt; f =&gt; x =&gt; m(f)(n(f)(x))\nMULT = m =&gt; n =&gt; f =&gt; m(n(f))\nPOW = b =&gt; e =&gt; e(b)\nlambda_to_js = (bool) =&gt; bool(\"TRUE\")(\"FALSE\")\nlambda_to_int = (int) =&gt; {\n  return int(x =&gt; x + 1)(0)\n}"
  },
  {
    "objectID": "posts/20250615-lambda-calculus/index.html#recap",
    "href": "posts/20250615-lambda-calculus/index.html#recap",
    "title": "Exploring Lambda Calculus (Part 3)",
    "section": "Recap",
    "text": "Recap\nLast time, we left off with our second truth table exploring Church Numerals and some incrementing mathematical operations. If you missed it, catch up here before moving on to this post’s topic: data structures and some new mathematical operations. 1"
  },
  {
    "objectID": "posts/20250615-lambda-calculus/index.html#data-structures",
    "href": "posts/20250615-lambda-calculus/index.html#data-structures",
    "title": "Exploring Lambda Calculus (Part 3)",
    "section": "Data Structures",
    "text": "Data Structures\nNow that we can represent numbers as functions, and critically, operate on them doing basic arithmetic, we need to find a way to store values for reference later. For example, the most basic of data structures is the n-tuple, which is an ordered list of n values.\nStoring values gets pretty tricky in lambda calculus – remember, everything is a function, and functions naturally want to execute their operations on their arguments. However, we can get around this by using a form of encapsulation.\nOur outer function will wrap the arguments, doing nothing with them. Then, when we need a value, we pass an successor function to the stored value, finally executing on it, and retrieving the real value. Straightforward? Not in the least.\nLet’s make some functions, then walk through them on the other side:\n\nBUILD_3TUPLE = a =&gt; b =&gt; c =&gt; f =&gt; f(a)(b)(c)\n\n\n\n\n\n\n\nGET_A = t =&gt; t(a =&gt; b =&gt; c =&gt; a)\n\n\n\n\n\n\n\nGET_B = t =&gt; t(a =&gt; b =&gt; c =&gt; b)\n\n\n\n\n\n\n\nGET_C = t =&gt; t(a =&gt; b =&gt; c =&gt; c)\n\n\n\n\n\n\nIn the above BUILD_3TUPLE, can you decipher which part is our “tuple”? Indeed, it is the portion f =&gt; f(a)(b)(c)! This is because the function f doesn’t actually do anything, it’s just going to hold on to the tuple (a,b,c) until we need them.\nOnce we do need them, it’s time to call our accessor functions! These GET_* functions all do the same thing: retrieve the positional value by using t to unwrap the tuple, and only return the position we need.\nLet’s try an example, where we want to extract the middle value from the tuple (0, 1, 2).\n\n{\n  const tuple = BUILD_3TUPLE(N0)(N1)(N2)\n  const b_val = GET_B(tuple)\n  return lambda_to_int( b_val )\n}\n\n\n\n\n\n\nUsing this idea, we can now implement a decrementing function – a procedure that seems fairly trivial, considering we have it’s counterpart already defined. However, it’s not so straight forward as it appears.\nIncrementing something is easy with functions; if you recall, we just wrap another layer around the outside. However, to get the predecessor, you would have to unwrap a layer of the nested functions, which we have no great way of doing.\nInstead, we’ll have to keep values “in memory”. Let’s start by defining a 2-tuple (PAIR), and the needed accessors:\n\nPAIR = a =&gt; b =&gt; f =&gt; f(a)(b)\n\n\n\n\n\n\n\nFIRST = t =&gt; t(a =&gt; b =&gt; a)\n\n\n\n\n\n\n\nSECOND = t =&gt; t(a =&gt; b =&gt; b)\n\n\n\n\n\n\nWith this in hand, we can create a function known as shift-and-increment (or phi), which takes a pair of numbers and returns a new pair of the second number and its increment: (a, b) =&gt; (b, b+1).\nThere can be many uses for this (looking at you, linked lists), but for now, we will use the concept to achieve our decrement function. The phi of a pair will always contain it’s predecessor, so we can back our way into coming up with the previous number:\n\nPHI = p =&gt; PAIR( SECOND(p) )( SUCC( SECOND(p) ) )\n\n\n\n\n\n\nAbove, we are forming a PAIR based on p (prior pair). This means that we want the second element of p to become the first of PHI: (SECOND(p)), and the increment/successor of the second element of p as the second element of PHI: (SUCC(SECOND(p))).\n\nPRED = n =&gt; FIRST( n(PHI)( PAIR(N0)(N0) ) )\n\n\n\n\n\n\n\nSUB = m =&gt; n =&gt; n(PRED)(m)\n\n\n\n\n\n\nIn the above, we are implementing PRED and then SUB, which utilizes PRED in its underlying logic.\nPRED is our decrement function, which takes a 2-tuple and starts counting up to it from (0,0). Once we hit our target number in the second position, we can then return the number in the first position, since we know that should be one less.\nSUB takes this farther by adding framework around PRED. Specifically, we are applying PRED n times to m. In other words, starting at m, we are then subtracting 1 from it n times. I will note this is not an efficient implementation whatsoever – for each step, we have to count up from 0 to get the prior number. It works fine here since our numbers are low, but if you imagine doing 1000-999, or something even more drastic, you can imagine how long it would take.\nUsing this idea, we can use a neat trick of the number functions themselves to check whether the number is 0 or not. Remember, a number is just the number of nested functions are in a stack - so 0 is represented by no functions in the stack. This is helpful because we can now check how many functions are called: any number of times &gt; 1 means it is not equal to 0, no calls means it is:\n\nISZERO = n =&gt; n(x =&gt; FALSE)(TRUE)\n\n\n\n\n\n\nSimilarly, we can take advantage of a feature of subtraction to find if a value is less than or equal to another. Technically, since none of our numbers are signed (how would you even add a sign based on nested functions???), we can just check if the result of subtracting the terms is 0. It’s ambiguous, yes (0 could mean the value is negative or 0), but in this case, we can use that “feature” to determine our inequality:\n\nLEQ = m =&gt; n =&gt; ISZERO( SUB(m)(n) )\n\n\n\n\n\n\nWith these brand new operations in hand, let’s update our truth table from last post with our newest functions:\n\npart_3_math_table = {\n  const output = [];\n  \n  [N0, N1, N2, N3, N4].forEach(a =&gt; {    \n    output.push({\n      n: lambda_to_int(a),\n      succ: lambda_to_int( SUCC(a) ),\n      plus: lambda_to_int( PLUS(a)(a) ),\n      mult: lambda_to_int( MULT(a)(a) ),\n      pow: lambda_to_int( POW(a)(a) ),\n      pred: lambda_to_int( PRED(a) ),\n      \"sub(2)\": lambda_to_int( SUB(a)(N2) ),\n      iszero: lambda_to_js( ISZERO(a) ),\n      \"leq(2)\": lambda_to_js( LEQ(a)(N2) )\n    })\n  })\n\n  return output\n}\n\n\n\n\n\n\n\nInputs.table(part_3_math_table)\n\n\n\n\n\n\n\nIn the immortal words of Bill and Ted, excellent! We’ve got some basic data structures and even more operations built out.\nI’m not yet sure if I’ll continue this series past this point, as I feel like I have a solid feel for lambda calculus at this point.\n-CH"
  },
  {
    "objectID": "posts/20250615-lambda-calculus/index.html#footnotes",
    "href": "posts/20250615-lambda-calculus/index.html#footnotes",
    "title": "Exploring Lambda Calculus (Part 3)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nInspired by Eric Wastl’s and Stuart Patience’s posts.↩︎"
  },
  {
    "objectID": "posts/20250430-lambda-calculus/index.html",
    "href": "posts/20250430-lambda-calculus/index.html",
    "title": "Exploring Lambda Calculus",
    "section": "",
    "text": "In short, lambda calculus is a pre-Turing machine implementation of computer programming. Rather than relying on memory, instructions, data structures, &c, lambda calculus only has functions. These functions carry a few rules:\n\nFunctions can only take 1 argument, and have 1 statement.\nClosures (encapsulated function environments) are allowed, and needed.\nWe can create aliases to help in shorthand, but all of the code muse be operable without doing anything that the original function cannot.\n\nWith those out of the way, let’s begin… 1"
  },
  {
    "objectID": "posts/20250430-lambda-calculus/index.html#introduction",
    "href": "posts/20250430-lambda-calculus/index.html#introduction",
    "title": "Exploring Lambda Calculus",
    "section": "",
    "text": "In short, lambda calculus is a pre-Turing machine implementation of computer programming. Rather than relying on memory, instructions, data structures, &c, lambda calculus only has functions. These functions carry a few rules:\n\nFunctions can only take 1 argument, and have 1 statement.\nClosures (encapsulated function environments) are allowed, and needed.\nWe can create aliases to help in shorthand, but all of the code muse be operable without doing anything that the original function cannot.\n\nWith those out of the way, let’s begin… 1"
  },
  {
    "objectID": "posts/20250430-lambda-calculus/index.html#basics",
    "href": "posts/20250430-lambda-calculus/index.html#basics",
    "title": "Exploring Lambda Calculus",
    "section": "Basics",
    "text": "Basics\n\nIDENTITY = x =&gt; x\n\n\n\n\n\n\nOur first function is very simple, but will show the foundation of what we are after.\nThis is the identity function, which returns exactly what the input is. Notice we are following all rules above: 1 argument & statement, &c\nLet’s extend that a little farther:\n\nRETURN_FIRST = a =&gt; b =&gt; a\n\n\n\n\n\n\n\nRETURN_FIRST(1)(2)\n\n\n\n\n\n\n\nRETURN_SECOND = a =&gt; b =&gt; b\n\n\n\n\n\n\n\nRETURN_SECOND(1)(2)\n\n\n\n\n\n\nIn the above functions, we are technically nesting a function within another, such that the argument of the first may or may not be called by the second function. RETURN_FIRST() and RETURN_SECOND() do exactly as they say, and this ‘switch’ ability is going to be key to start adding logic."
  },
  {
    "objectID": "posts/20250430-lambda-calculus/index.html#booleans-and-logic-gates",
    "href": "posts/20250430-lambda-calculus/index.html#booleans-and-logic-gates",
    "title": "Exploring Lambda Calculus",
    "section": "Booleans and Logic Gates",
    "text": "Booleans and Logic Gates\n\nTRUE = a =&gt; b =&gt; a\n\n\n\n\n\n\n\nFALSE = a =&gt; b =&gt; b\n\n\n\n\n\n\nThis may not seem like a lot, or more like a regurgitation of the sample switch return functions above, but this is critical to the base of our logic. The above are our replication of boolean states, which are identical to RETURN_FIRST and RETURN_SECOND – in fact, as we go on, it will be helpful to keep in mind that TRUE will always return the first argument, and FALSE the second.\nNaturally, these booleans can be combined together, creating AND/OR logic gates:\n\nAND = c =&gt; d =&gt; c(d)(c)\n\n\n\n\n\n\n\nOR = c =&gt; d =&gt; c(c)(d)\n\n\n\n\n\n\nAs you can see, the arguments to the functions above are all functions, and will return functions. For example (below), calling AND(TRUE)(FALSE) and OR(TRUE)(FALSE) will return the appropriate functions, either FALSE(), or TRUE().\nAs an example, let’s examine the AND() & OR() step by step:\n\nFirst, they accept two arguments, which we’ve seen before. In this function, the shorthand is c and d, but we’ll refer to them now as first and second arguments.\nOnce the arguments are collected, the bulk of the function is c(d)(c) or c(c)(d).\nWithin these blocks, the order is critical, as the positions of the arguments of TRUE() and FALSE() dictate what the end result will be.\n\nWe’re able to use creative permutations of returning the first (TRUE) and second (FALSE) values, giving us our basic AND/OR logic gates. As a thought experiment, let’s walk through all the possible permutations:\n\nAND(TRUE)(TRUE) will call TRUE(TRUE)(TRUE), returning: TRUE()\nAND(TRUE)(FALSE) will call TRUE(FALSE)(TRUE), returning: FALSE()\nAND(FALSE)(FALSE) will call FALSE(FALSE)(FALSE), returning: FALSE()\nAND(FALSE)(TRUE) will call FALSE(TRUE)(FALSE), returning: FALSE()\n\nLikewise, for OR():\n\nOR(TRUE)(TRUE) will call TRUE(TRUE)(TRUE), returning: TRUE()\nOR(TRUE)(FALSE) will call TRUE(TRUE)(FALSE), returning: TRUE()\nOR(FALSE)(FALSE) will call FALSE(FALSE)(FALSE), returning: FALSE()\nOR(FALSE)(TRUE) will call FALSE(FALSE)(TRUE), returning: TRUE()\n\nAnd just to confirm that this is working as expected:\n\nAND(TRUE)(FALSE) === FALSE\n\n\n\n\n\n\n\nOR(TRUE)(FALSE) === TRUE\n\n\n\n\n\n\nAs opposed to the above, NOT() looks like it will take 3 arguments rather than the 2 we’ve seen so far. However, the best way to think about it is that it takes only 1 argument: one of the other logic functions: AND(), OR(), &c.\nIn the function, consider c as the outer function (AND, OR, &c.), so instead of calling AND(a)(b), it acts as a wrapper around the logic gate and will flip the inputs, translating it into AND(b)(a). If you refer back to the AND()/OR() tables above, you can pretty clearly see how this would negate all the results.\nLet’s take a look:\n\nNOT = c =&gt; a =&gt; b =&gt; c(b)(a)\n\n\n\n\n\n\n\nNOT( AND(TRUE)(TRUE) ) === FALSE\n\n\n\n\n\n\nTo extend this idea of a wrapper, we can leave the input order the same, and get a ternary operator (IF) out of it (just as a shorthand), of the form IF(condition)(value if true)(value if false) like so:\n\nIF = c =&gt; a =&gt; b =&gt; c(a)(b)\n\n\n\n\n\n\n\nIF( AND(TRUE)(FALSE) )(TRUE)(FALSE) === FALSE\n\n\n\n\n\n\nNow the incredible part – using these, we can now create all the rest of the core logic gates:\n\nNAND = c =&gt; d =&gt; NOT( AND(c)(d) )\n\n\n\n\n\n\n\nNOR = c =&gt; d =&gt; NOT( OR(c)(d) )\n\n\n\n\n\n\n\nXOR = c =&gt; d =&gt; c( NOT(d) )(d)\n\n\n\n\n\n\n\nXNOR = c =&gt; d =&gt; c(d)( NOT(d) )\n\n\n\n\n\n\nAnd finally, with all these logic gates in hand, let’s extend the fledgling truth table from earlier to test all of these out. To do so, let’s build a helper function to let us parse out the values (since everything is a function, we need some real strings to populate the table).\n\nlambda_to_js = (bool) =&gt; bool(\"TRUE\")(\"FALSE\")\n\n\n\n\n\n\nAnd now we can map across all permutations of our logic gates:\n\npart_1_truth_table = {\n  const output = [];\n  \n  [TRUE, FALSE].forEach(a =&gt; {    \n    [TRUE, FALSE].forEach(b =&gt; {\n      output.push({\n        a: lambda_to_js(a),\n        b: lambda_to_js(b),\n        and: lambda_to_js( AND(a)(b) ),\n        or: lambda_to_js( OR(a)(b) ),\n        nand: lambda_to_js( NAND(a)(b) ),\n        nor: lambda_to_js( NOR(a)(b) ),\n        xor: lambda_to_js( XOR(a)(b) ),\n        xnor: lambda_to_js( XNOR(a)(b) )\n      })\n    })\n  })\n\n  return output\n}\n\n\n\n\n\n\n\nInputs.table(part_1_truth_table)\n\n\n\n\n\n\n\nGreat! We have created a full lambda calculus implementation of some logic gates! Now, this may seem trivial, but consider what is happening under the hood - we are using only functions to represent both values and operations.\nAs you’ll see next time, this can spiral out of control very quickly once we take a look at representing numbers and more complex operations.\n-CH"
  },
  {
    "objectID": "posts/20250430-lambda-calculus/index.html#footnotes",
    "href": "posts/20250430-lambda-calculus/index.html#footnotes",
    "title": "Exploring Lambda Calculus",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nInspired by Eric Wastl’s and Stuart Patience’s posts.↩︎"
  },
  {
    "objectID": "posts/20241206-advent-of-code/index.html",
    "href": "posts/20241206-advent-of-code/index.html",
    "title": "2024 Day 6: Guard Gallivant",
    "section": "",
    "text": "Day 6!\n\nPart 1\nToday, it feels like we are designing a videogame! I usually hide the input parsing, though I thought today’s was notable in that I found a better way to map out a grid using integer and mod division to calculate the starting position:\n\ninput = {\n  const map = raw.split('\\n').map(d =&gt; d.split(\"\")) // 2D array\n  const [nrow, ncol] = [map.length, map[0].length] // dims\n  const start_index = map.flat().indexOf(\"^\") // guard start\n  // use integer & mod div to find location\n  const [curr_row, curr_col] = [Math.floor(start_index/ncol), start_index % ncol]\n  const clean_map = map.slice()\n  clean_map[curr_row][curr_col] = '.' // replace so it's counted as an empty spot\n\n  const input = {\n    start: [curr_row, curr_col],\n    layout: clean_map,\n    dir: 0, // up\n    dims: [nrow, ncol]\n  }\n  \n  return input\n}\n\n\n\n\n\n\nNow that that is sorted, let’s proceed to part 1…\n\npossible_moves = [\n  [-1, 0], // up\n  [0, 1], // right\n  [1, 0], // down\n  [0, -1] // left\n]\n\n\n\n\n\n\nFirst, since we know we are navigating around a grid, let’s define movements in the four cardinal directions.\n\nmove_guard = (input, possible_moves) =&gt; {\n  const pos = [] // positions\n  let [[row, col], dir] = [input.start, input.dir]\n\n  while (true) { // until guard leaves grid\n    \n    // add current position and heading\n    pos.push([row, col, dir])\n\n    // get next pos and direction\n    const [next_row, next_col] = [row + possible_moves[dir][0], \n                                  col + possible_moves[dir][1]]\n    \n    // OOB check\n    if (next_row &lt; 0 || next_row &gt;= input.dims[0] || \n          next_col &lt; 0 || next_col &gt;= input.dims[1]) {\n      return pos\n    } \n\n    // if blocked, turn right\n    if (input.layout[next_row][next_col] === \"#\") {\n      dir = (dir + 1) % 4\n    }\n\n    // update position so it gets pushed for next iter\n    [row, col] = [row + possible_moves[dir][0], \n                  col + possible_moves[dir][1]]\n    \n  }\n}\n\n\n\n\n\n\nNow we’re getting serious – the main bulk of the problem!\nThis function traces the guard’s path by running through each step in a while loop. This way, we can set the condition to break on the guard leaving the bounds of our grid. Also, since we are keeping track of the direction using an integer, we can utilize it as an index with a little creative math.\nThough this function looks clean, it was not my first attempt. I originally thought that this would be a great use case for a recursive function – each call would move the guard a step forward, then call itself again (assuming it stayed in bounds). However, as soon as I scaled up to the full input, I exceeded the call stack, so I went back to the drawing board.\n\nnew Set(move_guard(input, possible_moves)\n      .map(d =&gt; JSON.stringify( [ d[0], d[1] ] ))).size\n\n\n\n\n\n\nOnce we have our function, it’s just a matter of finding the number of unique positions visited. I chose to do this with JSON.stringify(), then creating a Set from those strings and counting the length. After the fact, I saw someone’s solution for another day that used bitwise shifts and joins to calculate uniques (which I’ll use in Part 2).\nPart 1 complete!\n⭐\n\n\nPart 2\nUh oh, more complex now… we have to check how many discrete locations we can add an extra obstacle to in the guard’s path to send him into an infinite loop. This was daunting to start with, because anything that has to deal with checking for infinite loops seems difficult to do without launching into an infinite loop yourself. For example, if you revisit a specific location, who’s to say that your next step will continue the loop?\nHowever, after some pondering, I realized that that is not the case here. We have very specific rules about movement, so we can say with certainty that if a position is repeated, and a guard is facing the same way as before, then a loop is happening. In fact, we can abstract it away farther, and only care about checking the turn points for overlaps, since those are the ‘decision points’ where a loop could be entered.\n\ncheck_loop = (input, possible_moves) =&gt; {\n  const pos = new Set()\n  let [[row, col], dir] = [input.start, input.dir]\n  let turn = false\n\n  while(true) {\n    // if move is a turn\n    if (turn) {\n      // check if position and heading exists\n      const current_pos = (row &lt;&lt; 16) | (col &lt;&lt; 8) | dir\n      if (pos.has(current_pos)) {\n        // exit and say yes loop exists\n        return true\n      }\n      // otherwise add and keep going\n      pos.add(current_pos)\n    }\n\n    // get next pos and direction\n    const [next_row, next_col] = [row + possible_moves[dir][0], \n                                  col + possible_moves[dir][1]]\n\n    // OOB check\n    if (next_row &lt; 0 || next_row &gt;= input.dims[0] || \n          next_col &lt; 0 || next_col &gt;= input.dims[1]) {\n      return false // no loop, exits grid\n    }\n\n    if (input.layout[next_row][next_col] === \"#\") {\n      dir = (dir + 1) % 4\n      turn = true\n    } else {\n      row = next_row\n      col = next_col\n      turn = false\n    }\n  }\n}\n\n\n\n\n\n\nTo start, let’s modify the previous function to log all the positions as a Set, as well as tracking the heading in the position Set, as that will be critical to determining if we are in a loop.\nAnother change of note is we are now keeping a boolean flag turn to keep track of whether each move is a turn or not. This way, we can say that if the guard is turning, check if the position has been reached before; otherwise, continue as is onto the next step.\nIf you look closely, you’ll also see the bit shifting mentioned above being used to collapse row, col, and dir down to one number.\n\n{\n  // get unique route positions\n  const all_route = move_guard(input, possible_moves)\n    .map(d =&gt; (d[0] &lt;&lt; 8) | d[1] )\n  \n  const unique_pos = Array.from(new Set(all_route))\n    // multiply by masking hex codes to shorten down the bits \n    .map(d =&gt; ( [(d &gt;&gt; 8) & 0xFF, d & 0xFF] ))\n  \n  // keep track of new obstacles\n  const loop_counter = new Set()\n\n  // for each position on the route\n  unique_pos.forEach(d =&gt; {\n    // add obstacle\n    input.layout[ d[0] ][ d[1] ] = \"#\"\n    // see if loop exists\n    if (check_loop(input, possible_moves)) {\n      // add to tracker\n      loop_counter.add( (d[0] &lt;&lt; 8) | d[1] )\n    }\n    // reset layout for next iter\n    input.layout[ d[0] ][ d[1] ] = \".\"\n  })\n  // return unique counts\n  return loop_counter.size - 1 // duped the start position\n}\n\n\n\n\n\n\nUnfortunately, there wasn’t many better ways to find all the loops than to try each one, adding an obstacle to a different location each time. To shrink the search space some, I decided to only try adding obstacles to the locations that the guard visited in Part 1 – after all, if he never runs into it, then it won’t be a loop since we know that he exits cleanly with the default map.\nAnyways, we just need to iterate through those positions, modifying the grid and running our check_loop() function on each; once we have the resultant positions, we just need the count of uniques.\n⭐\n\nRamping up in difficulty for sure now!\n-CH"
  },
  {
    "objectID": "posts/20241204-advent-of-code/index.html",
    "href": "posts/20241204-advent-of-code/index.html",
    "title": "2024 Day 4: Ceres Search",
    "section": "",
    "text": "Day 4!\n\nPart 1\nAlright, now we are starting to get a little trickier – today we are doing a word search.\nIn the past, I have started by just brute forcing a grid traversal, checking all the neighbors as I go. However, I typically get burned by it, as part 2 ends up being more expensive of an operation than part 1. So, this time, I resolved to fins another method, and I landed on rotations!\nInstead of checking every direction from each letter, I check the whole grid as is (forward and back), then rotate and repeat – let’s begin:\n\nrotate_grid_90 = (grid) =&gt; {\n  // take first row, map across with indices and reverse the column order\n  return grid[0].map( (_, i) =&gt; grid.map( row =&gt; row[i] ).reverse() )\n}\n\n\n\n\n\n\nIn the above, this is the simplest of the rotations – we are taking each row and translating it into a column, and vice versa.\nSince we are checking forward and backward, it doesn’t matter too much about which direction we spin the 2D array. An issue I had for a while was that I was missing the reverse() call, which led to me reflecting the 2D array across the diagonal instead of rotating. I’m sure that there is a D3 method for some of this (maybe Arquero too?), but I wanted to do it from scratch.\n\nrotate_grid_45 = (grid) =&gt; {\n  // col, row (x, y)\n  const dims = [ grid[0].length, grid.length ]\n  // build array of indices of all values in the grids\n  const pos = Array.from(\n    new Set( // unique\n      Array(dims[0]).fill(0).map((_, i) =&gt; i)\n        .concat(Array(dims[1]).fill(0).map((_, i) =&gt; (dims[0]-1)+(dims[0]*i)))\n      // create array and fill with values (indices)\n    )\n  ) // [0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n  // create separate length calculations of pyramid\n  // based on even odd split\n  const lengths = pos.length % 2 === 0 ? \n    // even\n    new Array(pos.length/2).fill(0).map((_, i) =&gt; i)\n      .concat(new Array(pos.length/2)\n                        .fill(0).map((_, i) =&gt; i).reverse()) :\n    // odd\n    new Array(Math.floor(pos.length/2) + 1).fill(0).map((_, i) =&gt; i)\n      .concat(new Array(Math.floor(pos.length/2))\n                        .fill(0).map((_, i) =&gt; i).reverse())\n  // [1, 2, 3, 2, 1]\n\n  // create index map based on diffs from translation\n  const all_positions = lengths.map((d, i) =&gt; {\n    return [pos.slice()[i]]\n      .concat( \n        new Array(d)\n          .fill(0)\n          .map( (_, i) =&gt; (i + 1)*(dims[0]-1) )\n      ).reduce( \n          (acc, nxt, i) =&gt; {\n          return i === 0 \n            ? [nxt] \n            : acc.concat(acc[0] + nxt)\n          },\n        []\n      )\n  })\n  // [[0]        // 1 length\n  //  [1, 3]     // 2\n  //  [2, 4, 6]  // 3\n  //  [5, 7]     // 2\n  //  [8]]       // 1\n\n  const grid_vals = grid.reduce((acc, nxt) =&gt; acc.concat(nxt))\n  return all_positions.map(row =&gt; row.map(col =&gt; grid_vals[col]))\n}\n\n\n\n\n\n\nNow this function is to rotate 45 degrees to check the diagonals. This ends up being far more complex than a 90 degree rotation because the resultant arrays aren’t of equal length.\nFirst, in pos we need to create an array that has all the indices of the input 2D array. This was easier mentally to arrange, then just substitute at the end, though I’m sure this step could now be refactored if desired. Next, with lengths I wanted to calculate the lengths of each array in the pyramid arrangement of arrays after the rotation. This will allow a mapping function later to iterate through and fill with the needed values.\nFinally, the last step of our prepatory steps is to wrap all the indices into the correct positions (thus all_positions). Of note, this includes a calculation to increase the step of each index by the dimensions of the original 2D array – since the example is 3x3, the outer indices are [0, 1, 2, 5, 8], which wraps the first row and last column. With how we are rotating, those become the first indices in each resulting array, as they lead all the diagonals of our 45 degree rotation.\nThis means that each step is width of array - 1 = 2 in our example. If you picture it, you can concatenate all the arrays into one long number line, and you want 1 less than a perfect row in order to create a diagonal. Lastly, we just map across the resulting indices and substitute our actual values back in.\n\ncheck_rows = (grid) =&gt; {\n  // check matches for XMAS\n  const forward = grid\n    .reduce((acc, row) =&gt; acc + [...row.join(\"\")\n                                    .matchAll(/XMAS/g)].length, 0 )\n  // check matches for SAMX -- could also reverse() string I guess\n  const backward = grid\n    .reduce((acc, row) =&gt; acc + [...row.join(\"\")\n                                    .matchAll(/SAMX/g)].length, 0 )\n  return forward + backward\n}\n\ncheck_cols = (grid) =&gt; {\n  const col_grid = rotate_grid_90(grid)\n  const up = col_grid\n    .reduce((acc, row) =&gt; acc + [...row.join(\"\")\n                                    .matchAll(/XMAS/g)].length, 0 )\n  const down = col_grid\n    .reduce((acc, row) =&gt; acc + [...row.join(\"\")\n                                    .matchAll(/SAMX/g)].length, 0 )\n  return up + down\n}\n\ncheck_diag = (grid) =&gt; {\n  const up_diag = rotate_grid_45(grid)\n    .reduce((acc, row) =&gt; acc + [...row.join(\"\")\n                                    .matchAll(/XMAS/g)].length, 0 )\n  const down_diag = rotate_grid_45(grid)\n    .reduce((acc, row) =&gt; acc + [...row.join(\"\")\n                                    .matchAll(/SAMX/g)].length, 0 )\n  return up_diag + down_diag\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, all we have to do is create helper functions for each direction – horizontal, vertical (rotated horizontal), and diagonal (rotated 45 horizontal). Each of them checks for both XMAS and SAMX, that way we can minimize rotations.\n\n{\n  const grid = raw.split('\\n').map(d =&gt; d.split(\"\"))\n  return check_rows(grid) + check_cols(grid) + \n         check_diag(grid) + check_diag(rotate_grid_90(grid))\n}\n\n\n\n\n\n\nOnce the helpers are made, we just have to sum them! Note that we have two 45 degree rotations – one is to get the upper-left to lower-right diagonal, and the other is the upper-right to lower-left diagonal. Since we already have a 90 degree rotation, we can get the perpendicular diagonal by combining a 90 + 45 rotation, giving us our 0 degree, 90 degree, 45 degree, and 135 degree totals!\n⭐\n\n\nPart 2\nUnfortunately, I out-thought myself. Part 2 was far simpler than part 1 in this case, so I went back and created a new process to walk each cell (excluding the border):\n\nwalk_grid_no_border = (grid, fn) =&gt; {\n  // row, col\n  const inner_dims = [grid.length - 2, grid[0].length - 2]\n  // copy grid\n  const output_grid = grid.slice()\n  // map across every inner cell (not borders)\n  for (let i = 1; i &lt;= inner_dims[0]; i++) {\n    for (let k = 1; k &lt;= inner_dims[1]; k++) {\n      // call function on each cell, store result in new grid\n      output_grid[i][k] = fn(grid.slice(), i, k)\n    }\n  }\n  return output_grid\n}\n\n\n\n\n\n\nAs mentioned, this walks each cell, and performs a lambda function on it, passed through as an argument. This way, if I need to walk a grid in the future, I should be able to reuse this one!\n\ncheck_cell = (grid, row, col) =&gt; {\n  // get cell\n  const cell = grid[row][col]\n  // A will always be the intersection\n  if (cell !== \"A\") return cell\n  // look up diagonal characters\n  const diags = [\n    [ grid[row-1][col-1], grid[row+1][col+1] ],\n    [ grid[row+1][col-1], grid[row-1][col+1] ]\n  ]\n  // make sure each diagonal has an 'M' and an 'S'\n  return diags.map(d =&gt; d.includes(\"M\") && d.includes(\"S\")).every(elem =&gt; elem)\n}\n\n\n\n\n\n\nAgain, fairly straightforward, for each cell, I want to check each adjacent diagonal to see if they qualify, using A as the pivot point. I also had to pass a shallow copy of the the grid in so that when I replace a cell value with the boolen answer, it won’t impact further checks in the next row(s).\n\n{\n  const grid = raw.split('\\n').map(d =&gt; d.split(\"\"))\n  return walk_grid_no_border(grid, check_cell)\n    .flatMap(d =&gt; d.filter(elem =&gt; elem == 1))\n    .length\n}\n\n\n\n\n\n\nOnce we have those two functions, it’s just a matter of mapping them across the input! We should be fairly well set up for future grid questions where we have to walk the input – and any rotations!\n⭐\n\n-CH"
  },
  {
    "objectID": "posts/20241202-advent-of-code/index.html",
    "href": "posts/20241202-advent-of-code/index.html",
    "title": "2024 Day 2: Red-Nosed Reports",
    "section": "",
    "text": "Time for some day 2 action!\n\nPart 1\n\ncheck_validity &lt;- function(vec) {\n    # check if vec == sort(vec) or rev(sort(vec)), we know it is asc or desc\n    if ( !identical(sort(vec), vec) && !identical(rev(sort(vec)), vec) ) {\n      return(0)\n    }\n    # if it is, subtract each from the value that comes before it\n    diffs &lt;- vec[1:length(vec)-1] - lead(vec)[!is.na(lead(vec))]\n    # check all diffs are ints -3 &lt;= x &lt;= 3, where x != 0\n    if ( all(abs(diffs) %in% c(1:3)) ) {\n      return(1)\n    } else {\n      return(0)\n    }\n}\n\nSince we are repeating the same operation across each input row, let’s create a function to map across each row:\n\nFirst, we need to check that all sequences are either ascending or descending – and we accomplish that by using sort() and rev(). If the input vector doesn’t match the sorted or reverse sorted vector, then we know it is out of order and can skip it. However, if it matches one of them, then we can proceed.\nThe next step is to subtract each number from the one that precedes it, which we accomplish with lead(). It could also be done coming from the other side with lag(), just preference to come at it from this side. Once we have all of our diffs (and have ditched the NAs from the lead() shift), we can take the absolute value of each and check that they are all either 1, 2, or 3.\n\n\nraw %&gt;% \n  str_split('\\\\n') %&gt;% \n  list_c() %&gt;% \n  str_trim() %&gt;% \n  str_split(\"\\\\s+\") %&gt;% \n  # map our function across each input row\n  map(~ check_validity(as.numeric(.x))) %&gt;% \n  list_c() %&gt;% \n  sum()\n\n[1] 326\n\n\nNow that our function is complete, all we have to do for this part is clean up the input, split on each row, and map our function across each item in the list! Since we encoded the function output as 1’s and 0’s, we can easily sum to get the count of passing rows.\n⭐\n\n\nPart 2\n\nbuild_shift_list &lt;- function(vec) {\n\n  all_variations &lt;- list(vec)\n\n  # for each step subset a different portion\n  for (shift in 1:length(vec)) {    \n    append(\n      all_variations, \n      # head counts from the front, tail counts from the back\n      list( c( head(vec, shift-1), tail(vec, length(vec)-shift) ) )\n    ) -&gt; all_variations\n  }\n  \n  return(all_variations)\n\n}\n\nIn part two, we have to consider each variation of the input sequence created by deleting each number from that sequence. This calls for another function, which is pretty straightforward – we first count the length of the row, and then iterate through the row, removing each number at a time (and not forgetting to include the original vector in the return list).\n\nraw %&gt;% \n  str_split('\\\\n') %&gt;% \n  list_c() %&gt;% \n  str_trim() %&gt;% \n  str_split('\\\\s+') %&gt;% \n  # map across each to build a list of options within the outer list\n  map(~ build_shift_list(as.numeric(.x))) %&gt;% \n  # at depth 2 (list of lists), run function from before\n  map_depth(.depth = 2, check_validity) %&gt;% \n  # summarise each sublist -- if any are 1, then count all as 1\n  map(~ ifelse( any(.x == 1), 1, 0 )) %&gt;% \n  list_c() %&gt;% \n  sum()\n\n[1] 381\n\n\nNow that that is sorted, we can do almost the exact same as for Part 1; however, we need two new lines to:\n\nGet our shifted lists, which will create a hierarchy of lists\n\nex: [ [1, 2, 3], [2, 3], [1, 3], [1, 2] ]\n\nMap our first function across those sublists (which are depth 2 on our traversal tree)\n\nEasy enough!\n⭐\n\nPerhaps we mix up the language for tomorrow?\n-CH"
  },
  {
    "objectID": "posts/20241115-whats-next/index.html",
    "href": "posts/20241115-whats-next/index.html",
    "title": "What’s Next?",
    "section": "",
    "text": "I’m Back!\nIt’s been a long while since I’ve posted, as lots has happened over the last couple of months.\nMost notably, I’ve moved to NYC from Carlsbad, CA (goodbye, beaches!), and settled in quite nicely. The city is fantastic, and I am enjoying catching up with friends in the area!\n\n\nWhat’s next?\nOver the next little while, I plan to post every so often, with a wide variety of topics, from anything Civil War to Computer/Data Science to anything else that comes up.\nPrimarily, I plan to enter into the Advent of Code again this year, using various languages to really test my skills. Obviously, R is my first and greatest, and Python to a lesser extent – but over the last few months, I’ve been picking up ObservableJS. I primarily plan to use OJS for D3 and Plot visualizations, which of course necessitates learning the language in a greater sense as well.\nSince Quarto has functionality to support R, Python, and OJS cells – all interoperably, I might add – who knows what will happen this year! I may flip around depending on the problem; for example, tasks dealing with navigating maps lends itself to a tibble structure, whereas set and lists are far easier to manage in Python and/or OJS.\n\nAs we go along, the topics will jump around, but that is the exciting part! I also do not plan on having any sort of schedule, so the posts will come just as sporadically as ever – how fun!\n-CH"
  },
  {
    "objectID": "posts/20230910-california-burritos/index.html",
    "href": "posts/20230910-california-burritos/index.html",
    "title": "The Definitive Ranking of California Burritos",
    "section": "",
    "text": "What Are They?\nCalifornia burritos are very near and dear to me - if I go to a Mexican restaurant, I will undoubtedly get their version of a California burrito. No matter where I am, it’s always a great benchmark to compare against other restaurants.\nWhat is defining feature of the California burrito? Fries.\nAdding fries to a burrito elevates it to a whole other level; standard burritos just can’t compare. Add in the rest of your favorite toppings, and you have a wonderful burrito in your hands - but it all starts with the fries.\nIt must also be noted that a classic California burrito will have carne asada as the meat. Other versions do exist (for example, replacing the carne asada with chicken makes it an Arizona burrito), but none can compete with a perfectly executed California burrito.\n\n\nThe Rankings\nAll that to say, there are very important things that can separate one California burrito from another.\nWithout further ado, here are my rankings for best California burritos I have ever had:\n\nAlejandro’s (Carlsbad, CA) - CLOSED\nVallarta’s (Carlsbad, CA)\nThe Taco Stand (Encinitas, CA)\nElectric Burrito (New York City, NY)\nRoberto’s (Carlsbad, CA)\nCessy’s (Carlsbad, CA) - CLOSED\n\n\nIf you ever get a chance, seek out one of the above locations - or even make one yourself. I can all but guarantee that you won’t be disappointed.\n-CH"
  },
  {
    "objectID": "posts/20221211-ga-runoff/index.html",
    "href": "posts/20221211-ga-runoff/index.html",
    "title": "Cable News Coverage of the Georgia Runoffs",
    "section": "",
    "text": "After a deadlocked election night back in November that was much too close to call, the Georgia Senate election headed to a runoff. This election was held a few days ago, and finally settled once and for all who would be the newest Senator for Georgia.\nSenator Raphael Warnock won re-election to the U.S. Senate. Now, re-election comes with an asterisk, since his previous term was only two years (the result of a special election)."
  },
  {
    "objectID": "posts/20221211-ga-runoff/index.html#footnotes",
    "href": "posts/20221211-ga-runoff/index.html#footnotes",
    "title": "Cable News Coverage of the Georgia Runoffs",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n“Mediaite Cable News Ratings”↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Posts",
    "section": "",
    "text": "Posts\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\nA Visualization About Nothing\n\n\nD3: Exploring the Relationships of Seinfeld\n\n10 min\n\n\nOJS\n\nTV\n\nAnalysis\n\n\n\n\nJun 29, 2025\n\n\n\n\n\n\n\n\n\n\nExploring Lambda Calculus (Part 3)\n\n\nMucking Around with Pre-Turing Computer Programming\n\n6 min\n\n\nOJS\n\n\n\n\nJun 15, 2025\n\n\n\n\n\n\n\n\n\n\nExploring Lambda Calculus (Part 2)\n\n\nMucking Around with Pre-Turing Computer Programming\n\n5 min\n\n\nOJS\n\n\n\n\nMay 20, 2025\n\n\n\n\n\n\n\n\n\n\nExploring Lambda Calculus\n\n\nMucking Around with Pre-Turing Computer Programming\n\n6 min\n\n\nOJS\n\n\n\n\nApr 30, 2025\n\n\n\n\n\n\n\n\n\n\n2024 Day 7: Bridge Repair\n\n\nAdvent of Code\n\n36 min\n\n\nAdvent of Code\n\nOJS\n\n\n\n\nDec 7, 2024\n\n\n\n\n\n\n\n\n\n\n2024 Day 6: Guard Gallivant\n\n\nAdvent of Code\n\n8 min\n\n\nAdvent of Code\n\nOJS\n\n\n\n\nDec 6, 2024\n\n\n\n\n\n\n\n\n\n\n2024 Day 5: Print Queue\n\n\nAdvent of Code\n\n4 min\n\n\nAdvent of Code\n\nOJS\n\n\n\n\nDec 5, 2024\n\n\n\n\n\n\n\n\n\n\n2024 Day 4: Ceres Search\n\n\nAdvent of Code\n\n10 min\n\n\nAdvent of Code\n\nOJS\n\n\n\n\nDec 4, 2024\n\n\n\n\n\n\n\n\n\n\n2024 Day 3: Mull it Over\n\n\nAdvent of Code\n\n4 min\n\n\nAdvent of Code\n\nOJS\n\n\n\n\nDec 3, 2024\n\n\n\n\n\n\n\n\n\n\n2024 Day 2: Red-Nosed Reports\n\n\nAdvent of Code\n\n32 min\n\n\nAdvent of Code\n\nR\n\n\n\n\nDec 2, 2024\n\n\n\n\n\n\n\n\n\n\n2024 Day 1: Historian Hysteria\n\n\nAdvent of Code\n\n39 min\n\n\nAdvent of Code\n\nOJS\n\nR\n\n\n\n\nDec 1, 2024\n\n\n\n\n\n\n\n\n\n\nWhat’s Next?\n\n\nBack for More\n\n2 min\n\n\nUpdate\n\nAdvent of Code\n\n\n\n\nNov 15, 2024\n\n\n\n\n\n\n\n\n\n\nBaker’s Guard Zouaves\n\n\nThe Irish Skirmishers\n\n5 min\n\n\nCivil War\n\nReenacting\n\nHistory\n\n\n\n\nSep 17, 2023\n\n\n\n\n\n\n\n\n\n\nThe Definitive Ranking of California Burritos\n\n\nThe Best and Where to Get Them\n\n2 min\n\n\nFood\n\nRanking\n\n\n\n\nSep 10, 2023\n\n\n\n\n\n\n\n\n\n\nCable News Coverage of the NY Trump Arraignment\n\n\nA deep dive in content analysis\n\n6 min\n\n\nNews\n\nAnalysis\n\nR\n\n\n\n\nApr 8, 2023\n\n\n\n\n\n\n\n\n\n\nCable News Coverage of the Georgia Runoffs\n\n\nA deep dive in content analysis\n\n4 min\n\n\nNews\n\nAnalysis\n\nR\n\n\n\n\nDec 11, 2022\n\n\n\n\n\n\n\n\n\n\nJohn Hardy vs. John Henry\n\n\nDisentangling the Ballads\n\n5 min\n\n\nMusic\n\nHistory\n\n\n\n\nOct 24, 2022\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "monographs",
    "section": "",
    "text": "This blog is a collection of various short studies on topics that interest me, which I publish sporadically.\nClick the “posts” button below, or go back to the homepage to browse all posts.\nFor further information about me, please visit my website, linked below."
  },
  {
    "objectID": "posts/20221024-john-hardy-vs-henry/index.html#footnotes",
    "href": "posts/20221024-john-hardy-vs-henry/index.html#footnotes",
    "title": "John Hardy vs. John Henry",
    "section": "Footnotes",
    "text": "Footnotes\n\n\n“John Hardy” (1919) by John Harrington Cox.↩︎\n“John Hardy” (1919) by John Harrington Cox.↩︎\n“John Henry” (Library of Congress)↩︎\n“John Hardy” (1919) by John Harrington Cox.↩︎\n“John Hardy” (1919) by John Harrington Cox.↩︎\n“John Henry” (Library of Congress)↩︎\n“John Hardy” (1919) by John Harrington Cox.↩︎"
  },
  {
    "objectID": "posts/20230408-trump-arraignment-ny/index.html",
    "href": "posts/20230408-trump-arraignment-ny/index.html",
    "title": "Cable News Coverage of the NY Trump Arraignment",
    "section": "",
    "text": "The Indictment & Arraignment\nDuring Fmr. Pres. Donald Trump’s initial bid for the White House in 2016, he allegedly paid “hush money” to Stormy Daniels so as to prevent the affair story from leaking to the press. In doing so, it could be considered a federal crime - violation of campaign finance rules, since the entire alleged effort was in support of his campaign.\nSpecifically, he faced 34 counts of falsifying business records in the first degree. Of course, this is huge news, and as such, all the major news networks were following the indictment and arrest of a former president. During the legal process, no cameras were allowed inside the courtroom, so most of the networks filled the air with discussion and analysis; however, each network’s coverage was not at all the same.\n\n\nThe Stratification of Cable News\nLegal proceedings can be very dry, and an overall extremely boring affair. Not to mention federal trials, which disallow cameras in the courtrooms - so there is quite literally nothing to see.\nAs alluded to above, to fill the air, news networks had to turn to analysts, experts and pundits. Of course, these folks all have different backgrounds, areas of interest - and perhaps most importantly, differing political slants. Shortly, we will see how the coverage taken by the big three cable networks (CNN, MSNBC and FOX News) all covered the same events quite differently.\nHowever, the differences between cable news networks isn’t really news in and of itself - just about anyone can go on and on about the partisan news media and its many shortcomings. This is true, to some extent; however, there is an indisputable value of news coverage, regardless of the slant it may have.\nIf a news source is political, all that means is different varieties of coverage ought to be consumed to account for any shortcoming that one network or source may present. That said - enough of the philosophy of news networks and strategy - let’s dive into the similarities and differences in cable news network coverage of the NY Trump Arraignment.\n\n\nArraignment Coverage\nCertain words that are used can be very revealing about a network’s coverage - especially if they differ greatly from the other networks.\nIn my analysis, I aggregated all of the closed captions from CNN, FOX and MSNBC between the hours of 7 p.m. and 3 a.m. ET. In the industry, this time period is often referred to as Sales Prime, which is the block of coverage which sees the largest audiences across the board (it extends late in order to capture the West Coast too).\nAs a reminder, for each 10-minute block (since that is the granularity of data provided by the GDELT Project), any time the word “Trump” was said, all the words in that block were included. This way, the words most commonly said around “Trump” will be considered. These adjacent words were then lemmatized (cleaned and grouped) and fuzzily combined across networks to find the 200 most common mentions.\nThe top words per network are plotted below:\n\n\n\nSo what does this mean?\nLet’s start at the top, and work our way around clockwise, beginning with:\n\nFox News\nThe words clustering towards the top of this section do not differ greatly from something you may see on any other night. This leads me to believe that the coverage during prime time was not nearly as specialized on Fox News as it was on the other two networks.\nAt the very top of the list are two anchor names (Jesse Waters and Sean Hannity), but also Joe Biden. Clearly, much of the coverage that involved Trump also involved references to the current president. It is a little hard to tell the context surrounding some of these uses; however, it is quite clear that comparisons were being made between the two.\nBased on other events happening around the same time, I would suggest that most of the coverage on Fox News revolved around the failings of the current president, as opposed to the alleged crimes of the former one.\n\n\nMSNBC\nMSNBC’s coverage was much more directed around the actual arraignment and indictment of Fmr. Pres. Trump; however, the most common word was “Wisconsin” - which was a totally different story.\nIt just so happened that the day following the arraignment of Trump was a state supreme court election in Wisconsin - which could have huge impacts down the line for the purple state. You can even see that the word “election” is far down and right towards the MSNBC corner, which makes total sense. That said, MSNBC’s coverage of the upcoming election must’ve been deeply tied to Trump, since the state was mentioned so often in tandem with the former president’s name.\nOutside of the Wisconsin saga, there were many oblique references to the arraignment, including “Manhattan” (site of the courthouse), “judge”, “trial”, etc. Most interestingly is the word “Republican”, which is drifting towards the side of MSNBC, indicating that their coverage tended to be slightly more partisan than that of CNN, which also split usage of the word.\n\n\nCNN\nSimilar to MSNBC, CNN’s coverage was largely focused on the arraignment itself. Most unique is the word “Tacopina”, which is the name of one of Trump’s lawyers. This speaks to the angle of coverage - where MSNBC might have covered the generalities of the arraignment, whereas CNN dove in the specifics of the legal team, arraignment process, etc.\nAdditionally, other top unique words include “CNN” and “team”, which indicates a definite focus on live, team coverage of the event. This lines up with what I already know of the network - it prides itself on breaking news and live coverage.\nOther than the team-focused words, CNN’s coverage largely matches up with that of MSNBC - which doesn’t come as all that much of a surprise. After all, both have largely democratic leaning audiences (though, on aggregate, MSNBC does tend to drift farther left).\n\nOverall, the coverage was really divided into two camps: arraignment-related (CNN, MSNBC) and non-arraignment-related (MSNBC, Fox News). MSNBC straddles the line - both focusing on the arraignment as well as the Wisconsin election.\nThe fewer words that are clustered around the center, the more stratified the coverage has become. Hopefully, as we move forward with the trial, the words that the cable news networks use to describe Trump and his legal proceedings can re-coalesce around the center of the triangle - indicating a return to normalized coverage.\n-CH"
  },
  {
    "objectID": "posts/20230917-baker-zouave/index.html",
    "href": "posts/20230917-baker-zouave/index.html",
    "title": "Baker’s Guard Zouaves",
    "section": "",
    "text": "What are they?\nBaker’s Guard Zouaves were companies of Irish Zouaves as a part of the 69th Pennsylvania Volunteer Infantry Regiment. Specifically, they were companies I & K of the regiment, and functioned as flank companies and skirmishers for the regiment. However, this kind of functionality is quite standard for Zouaves of any nature during the civil war - so what makes these specific ones so special?\n\n\nHistory of the Zouave\nDuring the American Civil War, there was a definite craze for all things Zouave. Now, that can be hard to quantify, as there were many crazes of the time period - I mean half the country was trying to secede!\nHowever, this didn’t originate in the United States. In fact, the word “zouave” is French - it is a derivative of the original “Zouaouas”, the Berber tribe from which the first unit was to be levied for French service. The first unit of Zouaves was raised in Algeria in 1831 by the French, and they were outfitted with the traditional north-African clothing, including open jackets, baggy trousers, a fez-like hat, etc.\n\n\nZouaves in the US\nAs the Zouaves gained fame in the French army during their conquest of Africa, they became renowned as an elite fighting corps. Word quickly spread, through observers and military officials alike - soon everyone was talking about the fearsome Zouaves.\nThis included Elmer E. Ellsworth, an enterprising individual who obtained a Zouave training manual from his friend, who was a surgeon in the French North-African Zouave units. He then formed a touring company, which performed light infantry drills all over the nation, drumming up even more interest in these “foreign” soldiers.\n\nWhen the Civil War broke out, multiple units of Zouaves were formed, almost exclusively as militia units. Ellsworth’s own touring company became the 11th NY “Fire Zouaves”, on account of their red-trimmed uniforms.\nZouave uniforms were very similar to those of the French-Algerian troops: fez, baggy chasseur trousers, a shell jacket (which is open-fronted), jambieres (or gaiters), etc. These styles were often trimmed in red, both after the 11th NY and the original Zouaves - though they also had many swirls of embroidery as embellishments.\n\nFashion of the US during this time was also influenced by the famed Zouaves - tales of their exploits spread throughout the press, and many people wanted to dress like them as a result. Of course, men’s fashion was taken in with the designs, but more surprising was women’s fashion was as well. Many open-front Zouave-style jackets were worn as outerwear (as seen below), and the swirling, bold styles were also adopted into formal wear.\n\n\n\nBaker’s Guard Zouaves\nBaker’s Guard Zouaves were raised as two different companies before being attached to the 69th Pennsylvania Volunteer Infantry - I & K.\nCompany I was raised from two independent companies: “Gillen’s Independent Zouaves” and the “Philadelphia Zouave Cadets”.\nCompany K was raised from volunteers in Philadelphia by Cpt. William Davis, who was reported in the newspaper to be from the “gallant New York 69th”, another famed Irish regiment (from which the 69th Pennsylvania took it’s name).\nThe two regiments were named the “Baker’s Guard” Zouaves after Col. Edward D. Baker, who led the Philadelphia Brigade (of which the 69th Pennsylvania was assigned to).\nThese two companies, in the Zouave fashion, also had an extremely distinctive uniform. Similar to those of the 11th NY Fire Zouaves, and the 72nd and 95th Pennsylvania regiments of Zouaves, the Baker’s Guard Zouaves all wore the shortened shell jacket, vest, chasseur trousers, and jambieres; however, there were slight differences. As the rest of the units were trimmed in red, the Baker’s Guard uniforms were all trimmed in green, symbolic of their predominantly Irish heritage. Also, they opted to wear a kepi hat, also trimmed in green - rather than the traditional fez.\n\nWith such a different uniform, in the midst of war, one might assume they were only privately purchased - however, there are records of reissue:\n\nThis uniform was approved for reissue by the federal quartermasters in April of 1862, when Lieutenant Colonel George H. Crossman, Deputy Quartermaster at Philadelphia approved the manufacture of 160 uniforms “of the same pattern” which were known by the manufacturing firms of Rock & Wilson and Jacob Reed.\n\n\n\nBattle Record\nThe Baker’s Guard Zouaves, and to a greater extent the entire 69th Pennsylvania Infantry regiment, saw tons of action throughout the Civil war. Along with the Army of the Potomac, they fought in every major engagement from 1862 through the end of the war. Possibly most notably, the 69th Pennsylvania was pivotal in repelling Picket’s charge on day 3 of the battle of Gettysburg.\n\nOn a personal note, when I reenact the Civil War, I do so as a Baker’s Guard Zouave. My normal company portrays the post-Gettysburg version of Company A of the same regiment.\nIf you are interested in finding more about the Baker Guard Zouaves, they were Company K of the 69th Pennsylvania Volunteer Infantry, 2nd Brigade, 2nd Division, 2nd Corps, Army of the Potomac.\n-CH"
  },
  {
    "objectID": "posts/20241201-advent-of-code/index.html",
    "href": "posts/20241201-advent-of-code/index.html",
    "title": "2024 Day 1: Historian Hysteria",
    "section": "",
    "text": "Let’s get started with day 1!\nToday, after reading the problem, I feel like OJS will be easiest to handle all of these lists, so without further ado, let’s begin:\n\nPart 1\n\n{\n  const parsed = raw.split('\\n')\n      .map(d =&gt; {\n        return d.trimStart()\n                .replace(/\\s+/, '|')\n                .split('|')\n                .map(d =&gt; +d)\n      })\n\n  return parsed.map((d, i, me) =&gt; {\n      const diff = me.map(elem =&gt; elem[0]).sort()[i] - \n                   me.map(elem =&gt; elem[1]).sort()[i]\n      return diff &lt; 0 ? diff * -1 : diff\n    }).reduce((nxt, acc) =&gt; nxt + acc, 0)\n}\n\n\n\n\n\n\nFirst we need to parse out the input. I split on each newline, and used some regex to replace all the extra whitespace between the numbers with a delimeter, making splitting it into arrays quite simple.\nHowever, we need to map across the arrays and find the paired difference between the elements - after sorting - which I chose to do in one step using the this property of arrays when mapping.\nA simple conditional brings us home to our first star of the year!\nJust for fun, let’s do the same in R:\n\nraw %&gt;% \n  str_split(\"\\\\n\") %&gt;% \n  .[[1]] %&gt;% \n  map(str_squish) %&gt;% \n  map(~ str_split(.x, \" \")) %&gt;%\n  list_flatten() -&gt; parsed\n\nparsed %&gt;% \n  map(~ as.numeric(.x[[1]])) %&gt;% \n  list_c() %&gt;% \n  sort() %&gt;% \n  tibble(part_1 = .) %&gt;% \n  bind_cols({\n    parsed %&gt;% \n      map(~ as.numeric(.x[[2]])) %&gt;% \n      list_c() %&gt;% \n      sort() %&gt;% \n      tibble(part_2 = .)\n  }) -&gt; clean_data\n\nclean_data %&gt;% \n  mutate(diff = abs(part_2 - part_1)) %&gt;% \n  summarise(total = sum(diff)) %&gt;% \n  pull(total)\n\n[1] 2164381\n\n\nSimilar strategy as the OJS - parse the input and map across each set separately. However, this time, we’ll be taking advantage of the dataframe system in R, doing our calculations across columns, since the two lists are the same lengths.\n⭐\n\n\nPart 2\nSo for this part, we are tasked with counting the appearances of the first number list in the second, then multiplying across:\n\n{\n  const parsed = raw.split('\\n')\n      .map(d =&gt; {\n        return d.trimStart()\n                .replace(/\\s+/, '|')\n                .split('|')\n                .map(d =&gt; +d)\n      })\n  \n  const part_1 = parsed.map(d =&gt; d[0])\n  const part_2 = parsed.map(d =&gt; d[1])\n  \n  return part_1.reduce((acc, nxt) =&gt; {\n    return acc + nxt * ( part_2.filter(elem =&gt; elem === nxt).length )\n  }, 0)\n}\n\n\n\n\n\n\nNot too bad of a solution, just copied/pasted the parsing from above, and actually split it into two arrays now instead of doing it all at once. That way, a basic accumulation across the first array (which we are treating as the ‘keys’ in this case), nets us our answer. Another way to do it would be create an object from list #2, with each number as a key and each count as a value, which would eliminate the repeating lookups.\nAnd again in R:\n\nparsed %&gt;% \n  map(~ as.numeric(.x[[1]])) %&gt;% \n  list_c() %&gt;% \n  sort() %&gt;% \n  tibble(part_1 = .) %&gt;% \n  left_join({\n    parsed %&gt;% \n      map(~ as.numeric(.x[[2]])) %&gt;% \n      list_c() %&gt;% \n      sort() %&gt;% \n      tibble(part_2 = .) %&gt;% \n      count(part_2)\n  }, join_by(part_1 == part_2)) %&gt;% \n\n  mutate(prod = part_1 * n) %&gt;% \n  summarise(total = sum(prod, na.rm = T)) %&gt;% \n  pull(total)\n\n[1] 20719933\n\n\nEasy enough – just need to join the groups together into a dataframe rather than binding columns straight across. This way, the summarised totals will dupe themselves as needed per number.\n⭐\n\nNot too hard for day 1…\n-CH"
  },
  {
    "objectID": "posts/20241203-advent-of-code/index.html",
    "href": "posts/20241203-advent-of-code/index.html",
    "title": "2024 Day 3: Mull it Over",
    "section": "",
    "text": "Back for day 3!\n\nPart 1\nHopping back in OJS for today, felt like the regex is more natural to do in OJS than R.\n\n{\n  return [...raw.matchAll(/mul\\(\\d+,\\d+\\)/g)]\n    .reduce((acc, nxt) =&gt; {\n      const nums = [...nxt[0].matchAll(/\\d+/g)].map(elem =&gt; +elem[0])\n      return (nums[0] * nums[1]) + acc\n    }, 0)\n}\n\n\n\n\n\n\nThe first part here is pretty quick – we take our input and use regex to extract all mult(#, #) patterns in the string. Once we have all those extracted, all we have to do is pull out the numbers and multiply them together, and reduce to get our final answer.\nNot too shabby.\n⭐\n\n\nPart 2\nIn part 2, we have to only calculate the mult() tags that come after a do() instruction, but not after don't() tags.\nThe first cell below was my initial attempt to get the answer, but after thinking through my process, I was able to refactor and simplify it WAY down.\n\n{\n  const instructions = [...raw.matchAll(/mul\\(\\d+,\\d+\\)|do\\(\\)|don\\'t\\(\\)/g)]\n      .map(d =&gt; d[0])\n\n  let enable = true // set flag\n  \n  return instructions.reduce( (acc, nxt) =&gt; {\n      if ( /do\\(\\)/.test(nxt) ) { // matches do()\n        enable = true\n        return acc\n      } else if ( /don\\'t\\(\\)/.test(nxt) ) { // matches don't()\n        enable = false\n        return acc\n      } else { // matches mult\n        if (enable) { // if enabled add\n          const nums = [...nxt.matchAll(/\\d+/g)]\n              .map(elem =&gt; +elem[0])\n          return (nums[0] * nums[1]) + acc\n        } else { // otherwise skip\n          return acc\n        }\n      }\n    }, 0)\n}\n\n\n\n\n\n\nFirst up, the long solution. I basically modified the Part 1 regex to also extract all do() and don't() tags, as well as mult().\nThen, all we have to do is keep an enable boolean flag in memory, and as we map across the extracted commands, toggle it as needed. This way, we can skip all the unneeded mult()s and just sum up the products that we need.\n\n{\n  const cleaned_input = raw\n      .replaceAll(/\\n|\\r/g, '')\n      .replaceAll( /\\n|don\\'t\\(\\).*?do\\(\\)|don\\'t\\(\\).*/g, '')\n  return [...cleaned_input.matchAll(/mul\\(\\d+,\\d+\\)/g)]\n      .reduce((acc, nxt) =&gt; {\n        const nums = [...nxt[0].matchAll(/\\d+/g)]\n            .map(elem =&gt; +elem[0])\n        return (nums[0] * nums[1]) + acc\n      }, 0)\n}\n\n\n\n\n\n\nIn a much cleaner (and quicker?) solution, I realized I could remove all the don't()...do() instruction sets. Notably, this includes the special case of an unbounded don't() tag – the very last one that does not have a do() after it.\nThis way, the input is as clean as Part 1, and we can apply the same solution – extracting and mapping across the resultant mult() tags.\nKeen eyes might notice an extra line removing all line breaks and carriage returns. They were causing issues with some don't() tags not allowing the regex to carry into the next line, so adios to those!\n⭐\n\n-CH"
  },
  {
    "objectID": "posts/20241205-advent-of-code/index.html",
    "href": "posts/20241205-advent-of-code/index.html",
    "title": "2024 Day 5: Print Queue",
    "section": "",
    "text": "Day 5!\n\nPart 1\nLet’s jump in – today’s parts are both quite similar.\n\n{\n  const input = raw.split(\"\\n\\n\").map(d =&gt; d.split(\"\\n\"))\n  \n  const pages = {\n    numbers: new Set(), // unique pages\n    orders: new Map() // page =&gt; before\n  }\n  \n  // add all inputs to set & map\n  input[0].reduce(({numbers, orders}, nxt) =&gt; {\n    const [from, to] = nxt.match(/(\\d+)|(\\d+)/g)\n    numbers.add(+from)\n    numbers.add(+to)\n    orders.set( +from, (orders.get(+from) || new Array()).concat(+to) )\n    return pages\n  }, pages)\n\n  // clean up all books\n  const updates = input[1].map(d =&gt; d.split(\",\").map(elem =&gt; +elem))\n\n  // custom sort function\n  const page_sort = (update, order) =&gt; {\n    return update.slice().sort((a, b) =&gt; order.get(b)?.includes(a) ? 1 : -1)\n  }\n\n  // see if all are in order, if yes, then sum middle numbers\n  return updates\n    .filter((d) =&gt; {\n      return d.every((elem, i) =&gt; elem === page_sort(d, pages.orders)[i])\n    })\n    .map((d) =&gt; d[(d.length - 1)/2])\n    .reduce((acc, nxt) =&gt; acc + nxt, 0)\n}\n\n\n\n\n\n\nFor the first part, the parsing was the most diffcult part. And by difficult, I just mean more involved than usual – I opted to read it all into one object that has both a Set and a Map. This is my standard read option when we have ordering in the input. The set will give us all unique options, and the Map will maintain orderings and relationships, which comes in great use for this part.\nTo start, we have to use all the page numbering rules to check the orders of the updates (which I will call books going forward, since it flows better). This is fairly easy, all we have to do is sort the pages in each book using our custom comparator, then make sure that that array matches the initial array. All we have to do then is filter on those books that pass the test, extract their middle number (thankfully all of them are odd in length), and sum!\n⭐\n\n\nPart 2\nPart 2 was one of the easiest by far – all we have to do is negate our comparator function results. This time, we only want to keep the ones that are out of order, sort them, then pull out the middle numbers and sum!\n\n{\n  const input = raw.split(\"\\n\\n\").map(d =&gt; d.split(\"\\n\"))\n\n  const pages = {\n    numbers: new Set(),\n    orders: new Map()\n  }\n  \n  input[0].reduce(({numbers, orders}, nxt) =&gt; {\n    const [from, to] = nxt.match(/(\\d+)|(\\d+)/g)\n    numbers.add(+from)\n    numbers.add(+to)\n    orders.set( +from, (orders.get(+from) || new Array()).concat(+to) )\n    return pages\n  }, pages)\n\n  const updates = input[1].map(d =&gt; d.split(\",\").map(elem =&gt; +elem))\n\n  const page_sort = (update, order) =&gt; {\n    return update.slice().sort((a, b) =&gt; order.get(b)?.includes(a) ? 1 : -1)\n  }\n\n  // negate the every() statement from part 1\n  return updates\n    .filter((d) =&gt; {\n      return !d.every((elem, i) =&gt; elem === page_sort(d, pages.orders)[i])\n    })\n    // sort then count since they are in wrong order\n    .map(d =&gt; page_sort(d, pages.orders))\n    .map((d) =&gt; d[(d.length - 1)/2])\n    .reduce((acc, nxt) =&gt; acc + nxt, 0)\n}\n\n\n\n\n\n\n⭐\n\n-CH"
  },
  {
    "objectID": "posts/20241207-advent-of-code/index.html",
    "href": "posts/20241207-advent-of-code/index.html",
    "title": "2024 Day 7: Bridge Repair",
    "section": "",
    "text": "Day 7!\n\ninput = {\n  const clean = raw.split(\"\\n\")\n  clean.pop()\n\n  return clean.map(d =&gt; {\n    const parsed = [...d.matchAll(/\\d+/g)].map(elem =&gt; elem[0])\n    return {\n      target: +parsed[0].slice(),\n      operands: parsed.slice(1).map(elem =&gt; +elem)\n    }\n  })\n}\n\n\n\n\n\n\n\nPart 1\nIn this puzzle, we are given a bunch of numbers, and have to figure out how to reach the result by different operations. Those pesky elves stole all the operators!\n\n// go backwards along input -- if mod div === 0 then it's multiply, else add\ncheck_eq_step = (target, operands) =&gt; {\n  // final check\n  if (operands.length === 1) return operands[0] === target\n\n  // see if div by last factor\n  const div = target % operands[0] === 0\n  // see if subtractable by last factor\n  const sub = target &gt;= operands[0]\n\n  // if can't divide or subtract evenly then fail upwards\n  if (!div && !sub) return false\n\n  return (\n    // div case\n    (div && check_eq_step(  target / operands[0], operands.slice(1) )) ||\n    // sub case\n    (sub && check_eq_step( target - operands[0], operands.slice(1) ))\n  )\n}\n\n\n\n\n\n\nI first thought of trying to work through the equation recursively, left to right, but it quickly expanded into so many possible routes of combinations. After a while of tinkering, I landed on the above – working backwards through the equation. I realized that if the operation doesn’t cleanly work, then it’s invalid, and we can trim that route of options.\nThis way, we can prune the options as we go, without having to calculate to the end of the equation. For example, if we know the result is 200, and we know the last number in the equation is 201, we know the calculation is impossible because (a) 200 / 201 is not an integer, and (b) 200 - 201 is negative. Therefore, with one check, we can toss the whole equation, instead of only realizing it at the end!\n\ninput.filter(d =&gt; check_eq_step(d.target, d.operands.slice().reverse()))\n    .reduce((acc, nxt) =&gt; {\n      return acc + nxt.target\n    }, 0)\n\n\n\n\n\n\nOnce we have our function, it’s as easy as recursively applying it across the equation, and accumulating the result.\n⭐\n\n\nPart 2\nIn part 2, we now have to worry about string concatenation as a possible operator, instead of only multiplication and addition.\n\n// go backwards again, but add check for string end\ncheck_eq_step_2 = (target, operands) =&gt; {\n  // final check\n  if (operands.length === 1) return operands[0] === target\n\n  // see if div by last factor\n  const div = target % operands[0] === 0\n  // see if subtractable by last factor\n  const sub = target &gt;= operands[0]\n  // see if concat happened\n  const cat = String(target).endsWith(operands[0])\n\n  // if can't divide or subtract evenly then fail upwards\n  if (!div && !sub && !cat) return false\n  \n  return (\n    // div case\n    (div && check_eq_step_2( target / operands[0], operands.slice(1) )) ||\n    // sub case\n    (sub && check_eq_step_2( target - operands[0], operands.slice(1) )) ||\n    // concat case\n    (cat && check_eq_step_2( Number(String(target).slice(0, -String(operands[0]).length)), \n                             operands.slice(1) ))\n  )\n}\n\n\n\n\n\n\nHowever, this ends up being not too bad, as we can add an extra recursive step, and check the result and operator via slicing. For example, if the target is 156, and our operand is 6, then we have a match, since that would leave us with 15 (still working backwards here).\n\ninput.filter(d =&gt; check_eq_step_2(d.target, d.operands.slice().reverse()))\n  .reduce((acc, nxt) =&gt; {\n    return acc + nxt.target\n  }, 0)\n\n\n\n\n\n\nWith that little adjustment, we are all set!\n⭐\n\nNot too bad once you recognize going backwards will prune your sample space.\n-CH"
  },
  {
    "objectID": "posts/20250520-lambda-calculus/index.html",
    "href": "posts/20250520-lambda-calculus/index.html",
    "title": "Exploring Lambda Calculus (Part 2)",
    "section": "",
    "text": "Last time, we left off with our first truth table exploring all the logic gate test permutations. If you missed it, catch up here before moving on to this post’s topic: math and simple calculation. 1"
  },
  {
    "objectID": "posts/20250520-lambda-calculus/index.html#recap",
    "href": "posts/20250520-lambda-calculus/index.html#recap",
    "title": "Exploring Lambda Calculus (Part 2)",
    "section": "",
    "text": "Last time, we left off with our first truth table exploring all the logic gate test permutations. If you missed it, catch up here before moving on to this post’s topic: math and simple calculation. 1"
  },
  {
    "objectID": "posts/20250520-lambda-calculus/index.html#church-numerals",
    "href": "posts/20250520-lambda-calculus/index.html#church-numerals",
    "title": "Exploring Lambda Calculus (Part 2)",
    "section": "Church Numerals",
    "text": "Church Numerals\nNow that we have basic operations and logic gates, we need to advance past 1’s and 0’s to be able to represent more complex numerals. The difficulty here is going to be representing numerals with functions, for a few reasons:\n\nThere are an infinite number of numerals to represent\nHow can we combine the numerals using different functions, without defining the numerals themselves?\n\nWe are going to explore Church Numerals, which define a numeral N by encapsulating a function N times. This is pretty cool, as we are then no longer representing the numeral N as a “count”; instead, it becomes more of a “timer”. Let’s take a look:\n\nN0 = f =&gt; a =&gt; a // apply f 0 times\n\n\n\n\n\n\n\nN1 = f =&gt; a =&gt; f(a) // apply f 1 time\n\n\n\n\n\n\n\nN2 = f =&gt; a =&gt; f(f(a)) // apply f 2 times\n\n\n\n\n\n\n\nN3 = f =&gt; a =&gt; f(f(f(a))) // apply f 3 times\n\n\n\n\n\n\n\nN4 = f =&gt; a =&gt; f(f(f(f(a)))) // apply f 4 times\n\n\n\n\n\n\n… and so on. However, the absolute last thing I want to do is sit here and write more functions to define every number ever. So, let’s call it good here, and use this (admittedly) short list to test our operations with."
  },
  {
    "objectID": "posts/20250520-lambda-calculus/index.html#mathematical-operations",
    "href": "posts/20250520-lambda-calculus/index.html#mathematical-operations",
    "title": "Exploring Lambda Calculus (Part 2)",
    "section": "Mathematical Operations",
    "text": "Mathematical Operations\nSimilar to the idea of a “wrapper” function from last post (see NOT()), we need to define functions that will wrap around numbers to perform operations on them.\nThe first of these is the most simple, the successor function SUCC(). A fancy name for a basic operation, all this does is increment the number by 1. All it really is going to do is add another layer of wrapping around the number – that way, when we count the layers by “time”, our count, and therefore value, will have increased by 1.\n\nSUCC = n =&gt; f =&gt; x =&gt; f(n(f)(x))\n\n\n\n\n\n\nIn the above, f =&gt; x =&gt; f(n(f)(x)) creates our new number. To break it down further, n is the amount of times we are wrapping f around x, which means on its own, n(f)(x) is equal to n, the input number.\nThe crucial part of this function is the wrapper f() – as that is the piece which adds another “layer” to our number function, thereby incrementing its “count” by 1. If we substitute out the n discussed above for N (our numeral), this simplifies down to N =&gt; f(N), where the incrementation is far easier to spot.\nNow, we can move towards addition using the same principles. Instead of wrapping the “number” with one additional function call (successor), we need to wrap it with a variable number of functions:\n\nPLUS = m =&gt; n =&gt; f =&gt; x =&gt; m(f)(n(f)(x))\n\n\n\n\n\n\nIn the above, we achieve this by using the same “inner” variable for both functions, x. Accordingly, we want to apply f to x for each nested “number” function (m and n). Thus, we are applying f to x for m + n times, and following the same pattern of counting nested levels, we end up with our sum.\nThis principle is very extensible to multiplication – rather than operating on the same variable x, we want the “number” functions to operate on each other:\n\nMULT = m =&gt; n =&gt; f =&gt; m(n(f))\n\n\n\n\n\n\nRather than increasing the variable x first m times, then n times, we need to (increase the variable f n times) m times.\nA more verbose way to write MULT() would be to add the x variable back in:\nMULT = m =&gt; n =&gt; f =&gt; x =&gt; m(n(f))(x)\nIn this form, it is easier to see that instead of both m and n operating on f(x), we are instead having m operate on n, which is in turn operating on f(x).\nExponentiation takes this idea farther, and instead of using f(x) as the base we are incrementing, we want to increase the base, b, itself by e (exponent) amount of times.\n\nPOW = b =&gt; e =&gt; e(b)\n\n\n\n\n\n\nJust like in MULT(), there is a more verbose way to show this:\nPOW = b =&gt; e =&gt; f =&gt; x =&gt; e(b)(f)(x)\nHere, it’s less clean, but much clearer that e and b operate independently of f(x), and only once calculated, adds e(b) wrappers around f(x). Also, note that we are using f(x) here as the base, which is equal to 1 – if we had only x instead, we would end up with an incorrect amount of wrappers.\nWith these basic arithmetic functions, let’s test our shiny new operation functions on a (drumroll please…) new truth table with our short list of numbers!\nAs we did last time, we’ll need to create a helper function to convert the lambda functions to actual numerals…\n\nlambda_to_int = (int) =&gt; {\n  return int(x =&gt; x + 1)(0)\n}\n\n\n\n\n\n\n… letting us build our table!\n\npart_2_math_table = {\n  const output = [];\n  \n  [N0, N1, N2, N3, N4].forEach(a =&gt; {    \n    output.push({\n      n: lambda_to_int(a),\n      succ: lambda_to_int( SUCC(a) ),\n      plus: lambda_to_int( PLUS(a)(a) ),\n      mult: lambda_to_int( MULT(a)(a) ),\n      pow: lambda_to_int( POW(a)(a) )\n    })\n  })\n\n  return output\n}\n\n\n\n\n\n\n\nInputs.table(part_2_math_table)\n\n\n\n\n\n\n\nWoohoo! We’ve got some basic operations working now. However, you might have noticed that these operations are strictly incrementing our value.\nNext time, we’ll take a look at how to reverse the direction with subtraction, and the underlying data structures that that will require.\n-CH"
  },
  {
    "objectID": "posts/20250520-lambda-calculus/index.html#footnotes",
    "href": "posts/20250520-lambda-calculus/index.html#footnotes",
    "title": "Exploring Lambda Calculus (Part 2)",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nInspired by Eric Wastl’s and Stuart Patience’s posts.↩︎"
  },
  {
    "objectID": "posts/20250629-seinfeld-relationships/index.html",
    "href": "posts/20250629-seinfeld-relationships/index.html",
    "title": "A Visualization About Nothing",
    "section": "",
    "text": "Across all of Seinfeld, we see many relationships develop between the main four characters and many others. Explore the visualisation below to view all the many friends, family, girlfriends/boyfriends, and foes of the series!\nShow the Code\nrelationship_chart = {\n  const height = 800\n  const width = 1200\n\n  const color = d3.scaleOrdinal()\n    .domain(lookups.legend.map(d =&gt; d.type))\n    .range(lookups.legend.map(d =&gt; d.color))\n\n  const links = relationships.links.map(d =&gt; ({source: d.From, target: d.To, type: d.Type}))\n  const nodes = relationships.nodes.map(d =&gt; ({...d}))\n\n  const sim = d3.forceSimulation(nodes)\n    .force(\"link\", d3.forceLink(links).id(d =&gt; d.id).distance(100))\n    .force(\"charge\", d3.forceManyBody().strength(-50))\n    .force(\"collide\", d3.forceCollide().radius(20))\n    .force(\"center\", d3.forceCenter( width / 2, height / 2 ).strength(1.1))\n    .on(\"tick\", ticked)\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\")\n\n  const link = svg.append(\"g\")\n      .attr(\"stroke\", \"#999\")\n      .attr(\"stroke-opacity\", 0.6)\n    .selectAll()\n    .data(links)\n    .join(\"line\")\n      .attr(\"stroke-width\", 1.1)\n      .attr(\"stroke\", d =&gt; color(d.type))\n\n  const globs = svg.append(\"g\")\n      .attr(\"stroke\", \"#fff\")\n      .attr(\"stroke-width\", 1.1)\n    .selectAll(\"g\")\n    .data(nodes)\n    .enter()\n    .append(\"g\")\n\n  const node = globs.append(\"circle\")\n      .attr(\"r\", d =&gt; Math.max(3, Math.sqrt(d.count)+3))\n\n  node.append(\"title\")\n    .text(d =&gt; `${d.id} (${d.count})`)\n\n  globs.append(\"text\")\n    .text(d =&gt; d.id)\n    .attr(\"dy\", \"-1em\")\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"stroke\", \"black\")\n    .attr(\"stroke-width\", 0.1)\n    .style(\"font-size\", \"12px\")\n  \n  globs.call(d3.drag()\n           .on(\"start\", dragstarted)\n           .on(\"drag\", dragged)\n           .on(\"end\", dragended))\n\n  const legendDots = svg.append(\"g\")\n    .selectAll(\"legendDots\")\n    .data(lookups.legend.map(d =&gt; d.type))\n    .join(\"circle\")\n      .attr(\"cx\", width - 170)\n      .attr(\"cy\", (d, i) =&gt; height - 50 - i*20)\n      .attr(\"r\", 4)\n      .attr(\"fill\", d =&gt; color(d))\n\n  const legendText = svg.append(\"g\")\n    .selectAll(\"legendText\")\n    .data(lookups.legend.map(d =&gt; d.type))\n    .join(\"text\")\n      .attr(\"x\", width - 160)\n      .attr(\"y\", (d, i) =&gt; height - 50 - i*20)\n      .attr(\"text-anchor\", \"left\")\n      .style(\"alignment-baseline\", \"middle\")\n      .text(d =&gt; d)\n\n  const legendTitle = svg.append(\"g\")\n    .selectAll(\"legendTitle\")\n    .data([\"Relationship Types\"])\n    .join(\"text\")\n      .attr(\"x\", width - 190)\n      .attr(\"y\", height - 155)\n      .text(\"Relationship Types\")\n      .attr(\"text-anchor\", \"left\")\n      .style(\"text-decoration\", \"underline\")\n      .style(\"alignment-baseline\", \"middle\")\n\n  function ticked() {\n    globs\n      .attr(\"transform\", d =&gt; `translate(${d.x}, ${d.y})`)\n    \n    link\n      .attr(\"x1\", d =&gt; d.source.x)\n      .attr(\"y1\", d =&gt; d.source.y)\n      .attr(\"x2\", d =&gt; d.target.x)\n      .attr(\"y2\", d =&gt; d.target.y)\n\n  }\n\n  function dragstarted(event) {\n    if (!event.active) sim.alphaTarget(0.3).restart()\n    event.subject.fx = event.x\n    event.subject.fy = event.y\n  }\n\n  function dragged(event) {\n    event.subject.fx = event.x\n    event.subject.fy = event.y\n  }\n\n  function dragended(event) {\n    if (!event.active) sim.alphaTarget(0)\n    event.subject.fx = null\n    event.subject.fy = null\n  }\n\n  invalidation.then(() =&gt; sim.stop())\n  \n  return svg.node()\n\n}\nFilter the visualization below:\nShow the Code\nviewof characters = Inputs.checkbox(\n  lookups.characters, {\n  value: lookups.characters,\n  label: html`&lt;b&gt;Main Characters&lt;/b&gt;`\n  }\n)\nShow the Code\nviewof types = Inputs.checkbox(\n  lookups.legend.map(d =&gt; d.type).reverse(), {\n  value: lookups.legend.map(d =&gt; d.type).reverse(), \n  label: html`&lt;b&gt;Relationship Types&lt;/b&gt;`,\n  format: x =&gt; html`&lt;span style=\"text-transform: capitalize; border-bottom: solid 2px ${lookups.legend.filter(d =&gt; d.type === x)[0].color}; margin-bottom: -2px;\"&gt;${x}`\n})\nI took some inspiration from other visualizations1, but I really wanted to find a way to make it more interactive and dynamic. I’ve been slowly feeling my way through D3, so I figured it would be a great way to learn some of the d3.force* modules.\nUnfortunately, due to how tightly clustered these relationships are around the main characters, I did have to remove some links entirely which had no connection to the main four (ex: Micky Abbot’s mother). Due to the math of the forces involved, these disconnected nodes were being shot out into the void outside the canvas as soon as their connection to the main characters disappeared, rendering them pointless. From here, I’d explore different ways to dynamically render the text, as I’m not entirely satisfied with it – perhaps there is a way to check for overlaps, then only print the text that belongs to the larger node?\nSeinfeld is probably my all-time favorite series, so this was a lot of fun to make. While going through this project, I was hemming and hawing about which episode was my absolute favorite. In doing so, I couldn’t decide between two: The Stake Out and The Marine Biologist. The latter is as classic as it gets; I’m sure this is on most everyone’s lists. However, I think The Stake Out is a slept on episode for a few reasons:\nIf you’d like to explore the code behind the visualisation, continue below to the Appendix.\n-CH"
  },
  {
    "objectID": "posts/20250629-seinfeld-relationships/index.html#appendix",
    "href": "posts/20250629-seinfeld-relationships/index.html#appendix",
    "title": "A Visualization About Nothing",
    "section": "Appendix",
    "text": "Appendix\n\n\nShow the Code\n// Read in data and parse\nrelationships = {\n  let raw = await FileAttachment(\"seinfeld_relationships@7.json\").json(), \n      counts = new Object()\n  raw = raw.filter(d =&gt; (characters.includes(d.To) || characters.includes(d.From)) && (types.includes(d.Type)))\n  raw.map(d =&gt; d.From).forEach(d =&gt; {\n    return counts[d] ? counts[d]++ : counts[d] = 1\n  })\n  return {\n    nodes: Array.from(new Set(raw.map(d =&gt; d.From))).map(d =&gt; ({id: d, count: counts[d]})),\n    links: raw\n  }\n}\n\n\n\n\n\n\n\n\n\nShow the Code\n// Build lookup for values\nlookups = ({\n  legend: [\n    {type: \"Friend\", color: \"#2ca02c\"},\n    {type: \"Family\", color: \"#d62728\"},\n    {type: \"Antagonistic\", color: \"#ff7f0e\"},\n    {type: \"Romantic\", color: \"#1f77b4\"},\n    {type: \"Professional\", color: \"#9467bd\"}\n  ],\n  characters: [\"Jerry Seinfeld\", \"George Costanza\", \"Elaine Benes\", \"Cosmo Kramer\"]\n})\n\n\n\n\n\n\n\n\n\nShow the Code\n// Create character selection\nviewof characters = Inputs.checkbox(\n  lookups.characters, {\n  value: lookups.characters,\n  label: html`&lt;b&gt;Main Characters&lt;/b&gt;`\n  }\n)\n\n\n\n\n\n\n\n\n\nShow the Code\n// Create relationship type selection\nviewof types = Inputs.checkbox(\n  lookups.legend.map(d =&gt; d.type).reverse(), {\n  value: lookups.legend.map(d =&gt; d.type).reverse(), \n  label: html`&lt;b&gt;Relationship Types&lt;/b&gt;`,\n  format: x =&gt; html`&lt;span style=\"text-transform: capitalize; border-bottom: solid 2px ${lookups.legend.filter(d =&gt; d.type === x)[0].color}; margin-bottom: -2px;\"&gt;${x}`\n})\n\n\n\n\n\n\n\n\n\nShow the Code\n// Build D3 chart\nrelationship_chart = {\n  const height = 800\n  const width = 1200\n\n  const color = d3.scaleOrdinal()\n    .domain(lookups.legend.map(d =&gt; d.type))\n    .range(lookups.legend.map(d =&gt; d.color))\n\n  const links = relationships.links.map(d =&gt; ({source: d.From, target: d.To, type: d.Type}))\n  const nodes = relationships.nodes.map(d =&gt; ({...d}))\n\n  const sim = d3.forceSimulation(nodes)\n    .force(\"link\", d3.forceLink(links).id(d =&gt; d.id).distance(100))\n    .force(\"charge\", d3.forceManyBody().strength(-50))\n    .force(\"collide\", d3.forceCollide().radius(20))\n    .force(\"center\", d3.forceCenter( width / 2, height / 2 ).strength(1.1))\n    .on(\"tick\", ticked)\n\n  const svg = d3.create(\"svg\")\n    .attr(\"width\", width)\n    .attr(\"height\", height)\n    .attr(\"viewBox\", [0, 0, width, height])\n    .attr(\"style\", \"max-width: 100%; height: auto;\")\n\n  const link = svg.append(\"g\")\n      .attr(\"stroke\", \"#999\")\n      .attr(\"stroke-opacity\", 0.6)\n    .selectAll()\n    .data(links)\n    .join(\"line\")\n      .attr(\"stroke-width\", 1.1)\n      .attr(\"stroke\", d =&gt; color(d.type))\n\n  const globs = svg.append(\"g\")\n      .attr(\"stroke\", \"#fff\")\n      .attr(\"stroke-width\", 1.1)\n    .selectAll(\"g\")\n    .data(nodes)\n    .enter()\n    .append(\"g\")\n\n  const node = globs.append(\"circle\")\n      .attr(\"r\", d =&gt; Math.max(3, Math.sqrt(d.count)+3))\n\n  node.append(\"title\")\n    .text(d =&gt; `${d.id} (${d.count})`)\n\n  globs.append(\"text\")\n    .text(d =&gt; d.id)\n    .attr(\"dy\", \"-1em\")\n    .attr(\"text-anchor\", \"middle\")\n    .attr(\"stroke\", \"black\")\n    .attr(\"stroke-width\", 0.1)\n    .style(\"font-size\", \"12px\")\n  \n  globs.call(d3.drag()\n           .on(\"start\", dragstarted)\n           .on(\"drag\", dragged)\n           .on(\"end\", dragended))\n\n  const legendDots = svg.append(\"g\")\n    .selectAll(\"legendDots\")\n    .data(lookups.legend.map(d =&gt; d.type))\n    .join(\"circle\")\n      .attr(\"cx\", width - 170)\n      .attr(\"cy\", (d, i) =&gt; height - 50 - i*20)\n      .attr(\"r\", 4)\n      .attr(\"fill\", d =&gt; color(d))\n\n  const legendText = svg.append(\"g\")\n    .selectAll(\"legendText\")\n    .data(lookups.legend.map(d =&gt; d.type))\n    .join(\"text\")\n      .attr(\"x\", width - 160)\n      .attr(\"y\", (d, i) =&gt; height - 50 - i*20)\n      .attr(\"text-anchor\", \"left\")\n      .style(\"alignment-baseline\", \"middle\")\n      .text(d =&gt; d)\n\n  const legendTitle = svg.append(\"g\")\n    .selectAll(\"legendTitle\")\n    .data([\"Relationship Types\"])\n    .join(\"text\")\n      .attr(\"x\", width - 190)\n      .attr(\"y\", height - 155)\n      .text(\"Relationship Types\")\n      .attr(\"text-anchor\", \"left\")\n      .style(\"text-decoration\", \"underline\")\n      .style(\"alignment-baseline\", \"middle\")\n\n  function ticked() {\n    globs\n      .attr(\"transform\", d =&gt; `translate(${d.x}, ${d.y})`)\n    \n    link\n      .attr(\"x1\", d =&gt; d.source.x)\n      .attr(\"y1\", d =&gt; d.source.y)\n      .attr(\"x2\", d =&gt; d.target.x)\n      .attr(\"y2\", d =&gt; d.target.y)\n\n  }\n\n  function dragstarted(event) {\n    if (!event.active) sim.alphaTarget(0.3).restart()\n    event.subject.fx = event.x\n    event.subject.fy = event.y\n  }\n\n  function dragged(event) {\n    event.subject.fx = event.x\n    event.subject.fy = event.y\n  }\n\n  function dragended(event) {\n    if (!event.active) sim.alphaTarget(0)\n    event.subject.fx = null\n    event.subject.fy = null\n  }\n\n  invalidation.then(() =&gt; sim.stop())\n  \n  return svg.node()\n\n}"
  },
  {
    "objectID": "posts/20250629-seinfeld-relationships/index.html#footnotes",
    "href": "posts/20250629-seinfeld-relationships/index.html#footnotes",
    "title": "A Visualization About Nothing",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nhttps://flowingdata.com/2009/09/02/the-world-of-seinfeld/↩︎"
  }
]