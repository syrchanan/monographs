{
  "hash": "9f6a53eed0dbc1fc0bb8570fa36efece",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2024 Day 8: Resonant Collinearity\"\nsubtitle: \"Advent of Code\"\ndate: \"2025-07-10\"\nformat: \n  html: \n    code-line-numbers: false\ncategories:\n  - Advent of Code\n  - OJS\n  - R\ndraft: false\n---\n\nI'm back with more 2024 Advent of Code! Back in December, I solved about 18/25, though never copied them over from my Observable Notebooks. It's about time I post them here, so I'll be both catching up on old days as well as working to finish out the rest of the 2024 puzzles.\n\nWith further ado, let's get started with [day 8](https://adventofcode.com/2024/day/8)!\n\n\n::: {.cell tags='parameters'}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\nFirst, let's parse the input – this is fairly standard fare for Advent of Code. Grid parsing is probably one of the most common problem setups, so it's nothing a little regex can't fix. However, based on the problem (matching antennae based on matching character sets), I chose to use a `Map` object type. It could have easily been done with regular objects, but why not try something new?\n\n```{ojs}\n//| echo: true\n\ninput = {\n  // split on newlines and separate each char\n  const parsed = raw.split(\"\\n\").map(d => d.split(\"\"))\n\n  // create map of each antenna type\n  const antennae = parsed.reduce((acc, nxt, row) => {\n    nxt.forEach((elem, col) => {\n      if (elem !== \".\") {\n        acc.set( \n            elem, \n            [...acc.get(elem) || [], {row: row, col: col}] \n        )\n      }\n    })\n    return acc\n  }, new Map())\n\n  // return map and general grid info\n  return {\n      antennae: antennae, \n      nrow: parsed.length, \n      ncol: parsed[0].length, \n      grid: parsed\n  }\n}\n\n```\n\n### Part 1\n\nIn part 1, we need to find all the possible antinode locations, which are derived from pairs of matching antennae sets. To do so, we'll need to create a little bit of infrastructure below:\n\n```{ojs}\n\nfunction pairwise(arrays, dupes = false) {\n  // recursive so we need a short circuit\n  if (arrays.length === 0) return []\n  // extract matching item\n  const [first, ...rest] = arrays\n  // get all other pairs recursively\n  const end = pairwise(rest)\n  // if we allow dupes, nest them together\n  const other = end.map(([first2, rest2]) => {\n    return dupes\n      ? [first2, [first, ...rest2]]\n      : [first2, [...rest2]]\n  }) \n  return [[first, rest], ...other]\n}\n\n```\n\nAbove, we created a function to create all pairwise matches from an array. Using this, we can find all the locations of antinodes, since the new ones must be on the same plane as the existing antennae.\n\nOnce we have our pairs, then we actually have to find the possible locations. Luckily for us, this is quite simple, since we can use the good ol' slope formula to calculate the possible positions.\n\n```{ojs}\n\nfunction find_antinodes(a, b, n) {\n    // y2 - y1 / x2 - x1\n    const slope = [ a[0] - b[0], a[1] - b[1] ]\n    // return the new positions in both directions\n    return [\n      [ a[0] + n*slope[0], a[1] + n*slope[1] ],\n      [ b[0] - n*slope[0], b[1] - n*slope[1] ]\n    ]\n  }\n\n```\n\nWith these in hand, the solution becomes fairly trivial; all we need to do now is iterate through our input Map to:\n\n1.  Get all the pairwise matches of antennae in each group\n2.  Calculate the slope of each sub-pair\n3.  Count all unique antinode locations\n\n```{ojs}\n\npart_1 = {\n\n  const antinodes = []\n\n  // for each set\n  input.antennae.forEach(antenna_set => {\n    antinodes.push(\n      // get all pairwise matches\n      pairwise(antenna_set, false).flatMap(([ref, pair]) => {\n        return pair\n            // get the possible locations for each pair\n            .flatMap(d => find_antinodes( \n                [ref.row, ref.col], \n                [d.row, d.col], \n                1 )\n            )\n          // remove any outside grid boundaries\n      }).filter(([row, col]) => \n                row >= 0 &&\n                row < input.nrow &&\n                col >= 0 &&\n                col < input.ncol            \n      )\n    )\n  })\n\n  return new Set(\n    antinodes\n        .flat()\n        // combine coords with left shift and bitwise OR\n        .map(d => d[0] << 8 | d[1])\n    ).size\n\n}\n\n```\n\n```{ojs}\n//| echo: false\n\npart_1\n\n```\n\n⭐\n\n### Part 2\n\nIn part 2, the difference is that antinodes may be more than 1-step away from existing antennae. This makes it fairly easy, since we can just extend our functions from before to look at a longer range!\n\nWith a quick tweak to `n` in our `find_antinodes()` function (by using number of rows we can be sure that we will exceed the bounds for each antennae set in both directions), we can easily cross this day off our list!\n\n```{ojs}\n\npart_2 = {\n  const antinodes = []\n  // get array of row count to iterate across as N\n  const n_mults = Array(input.nrow).fill(0).map((_, i) => i+1)\n  \n  input.antennae.forEach(antenna_set => {\n    antinodes.push(\n      // same as before\n      pairwise(antenna_set, false).flatMap(([ref, pair]) => {\n        return n_mults.flatMap(n => {\n          // map across all N distances\n          return pair.flatMap(d => find_antinodes( [ref.row, ref.col], [d.row, d.col], n ))\n        })\n          // same filter as before to check boundaries\n      }).filter(([row, col]) => \n                  row >= 0 &&\n                  row < input.nrow &&\n                  col >= 0 &&\n                  col < input.ncol            \n      )\n    )\n  })\n\n  // left shift and bitwise OR\n  const all_antinode = antinodes.flat().map(d => d[0] << 8 | d[1])\n  // do the same for antennae positions, since they count in this part\n  const all_antennae = [...input.antennae.entries()]\n      .map(d => d[1])\n      .flat()\n      .map(d => d.row << 8 | d.col)\n\n  // count unique antinodes AND antennae\n  return new Set( [ ...all_antinode, ...all_antennae ] ).size\n}\n\n```\n\n```{ojs}\n//| echo: false\npart_2\n```\n\n⭐\n\n------------------------------------------------------------------------\n\nPretty fun day! I always enjoy a bit of regex, and some classic math to boot.\n\nI'm looking forward to catching up on a bunch of these AoC days, so stay tuned for more soon!\n\n-CH",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script type=\"ojs-define\">\n{\"contents\":[{\"name\":\"raw\",\"value\":\".............4....O..........w....R...............\\n.................................f................\\n..............4...j......NW0......................\\n....................R..W..........................\\n...............R..................................\\n..................................................\\nv.......................f.......0W................\\n.....9L............l...N.........w................\\n....L....9.......ON........8......................\\n.1.........49L........f..0..N.....................\\n..........................V...l...................\\n..........4.......................................\\n.....................j...................3.....U..\\n....O.....U.......................................\\n........J......................l..................\\n.O....s.Q.......j.....l.....w..........F...q......\\n..................................................\\n.U.......................j..8.....................\\n................U...............................3.\\n2.............................J............3......\\n..............................F...................\\n.....s...R...........J..................F.........\\n.s......................x..........F.....q........\\n.......2.....Q........3........x..................\\n...........v......................u...............\\n..............v...........n......8............q...\\n.......f..................8........i..............\\n.5..................1n..............P.....i.......\\n............7............Q..................X.....\\n......5...p....................V..................\\n.................J..........nx............q.......\\n.......p............W...........................0.\\n......2.............p.5.....1....P................\\n......I.................7.X....i...P..............\\n............s.....r...w................V..........\\n...............or...6.................V...........\\n............................PS.7..................\\n..........o...........................S...........\\n...........5..............o..1.......n............\\n...........I.........r.......7.......6............\\n.................o.r...........X..................\\n................................x.........u.......\\n.........p..Q....2................................\\n.........v.................S.....................u\\nI...........................S.....6...............\\n..................................................\\n.......I..........................................\\n..................................................\\n.......................................6..........\\n.................................X................\"}]}\n</script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}