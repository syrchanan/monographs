{
  "hash": "bc0aa59b13f8ab3f70da45ec44393b59",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"2024 Day 2: Red-Nosed Reports\"\nsubtitle: \"Advent of Code\"\ndate: \"2024-12-02\"\nformat: \n  html: \n    code-line-numbers: false\n# image: \"./ElmerEllsworthphoto01.jpg\"\ncategories:\n  - Advent of Code\n  - OJS\n  - R\ndraft: false\n---\n\n\n\nTime for some [day 2](https://adventofcode.com/2024/day/2) action!\n\n\n\n::: {.cell tags='parameters'}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n### Part 1\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_validity <- function(vec) {\n    # check if vec == sort(vec) or rev(sort(vec)), we know it is asc or desc\n    if ( !identical(sort(vec), vec) && !identical(rev(sort(vec)), vec) ) {\n      return(0)\n    }\n    # if it is, subtract each from the value that comes before it\n    diffs <- vec[1:length(vec)-1] - lead(vec)[!is.na(lead(vec))]\n    # check all diffs are ints -3 <= x <= 3, where x != 0\n    if ( all(abs(diffs) %in% c(1:3)) ) {\n      return(1)\n    } else {\n      return(0)\n    }\n}\n```\n:::\n\n\n\nSince we are repeating the same operation across each input row, let's create a function to map across each row:\n\n-   First, we need to check that all sequences are either ascending or descending -- and we accomplish that by using `sort()` and `rev()`. If the input vector doesn't match the sorted or reverse sorted vector, then we know it is out of order and can skip it. However, if it matches one of them, then we can proceed.\n\n-   The next step is to subtract each number from the one that precedes it, which we accomplish with `lead()`. It could also be done coming from the other side with `lag()`, just preference to come at it from this side. Once we have all of our diffs (and have ditched the NAs from the `lead()` shift), we can take the absolute value of each and check that they are all either 1, 2, or 3.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw %>% \n  str_split('\\\\n') %>% \n  list_c() %>% \n  str_trim() %>% \n  str_split(\"\\\\s+\") %>% \n  # map our function across each input row\n  map(~ check_validity(as.numeric(.x))) %>% \n  list_c() %>% \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 326\n```\n\n\n:::\n:::\n\n\n\nNow that our function is complete, all we have to do for this part is clean up the input, split on each row, and map our function across each item in the list! Since we encoded the function output as 1's and 0's, we can easily sum to get the count of passing rows.\n\n⭐\n\n### Part 2\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbuild_shift_list <- function(vec) {\n\n  all_variations <- list(vec)\n\n  # for each step subset a different portion\n  for (shift in 1:length(vec)) {    \n    append(\n      all_variations, \n      # head counts from the front, tail counts from the back\n      list( c( head(vec, shift-1), tail(vec, length(vec)-shift) ) )\n    ) -> all_variations\n  }\n  \n  return(all_variations)\n\n}\n```\n:::\n\n\n\nIn part two, we have to consider each variation of the input sequence created by deleting each number from that sequence. This calls for another function, which is pretty straightforward -- we first count the length of the row, and then iterate through the row, removing each number at a time (and not forgetting to include the original vector in the return list).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nraw %>% \n  str_split('\\\\n') %>% \n  list_c() %>% \n  str_trim() %>% \n  str_split('\\\\s+') %>% \n  # map across each to build a list of options within the outer list\n  map(~ build_shift_list(as.numeric(.x))) %>% \n  # at depth 2 (list of lists), run function from before\n  map_depth(.depth = 2, check_validity) %>% \n  # summarise each sublist -- if any are 1, then count all as 1\n  map(~ ifelse( any(.x == 1), 1, 0 )) %>% \n  list_c() %>% \n  sum()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 381\n```\n\n\n:::\n:::\n\n\n\nNow that that is sorted, we can do almost the exact same as for Part 1; however, we need two new lines to:\n\n-   Get our shifted lists, which will create a hierarchy of lists\n\n    -   ex: `[ [1, 2, 3], [2, 3], [1, 3], [1, 2] ]`\n\n-   Map our first function across those sublists (which are depth 2 on our traversal tree)\n\nEasy enough!\n\n⭐\n\n------------------------------------------------------------------------\n\nPerhaps we mix up the language for tomorrow?\n\n-CH",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}